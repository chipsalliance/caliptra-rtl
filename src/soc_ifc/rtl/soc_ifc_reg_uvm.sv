
// This file was autogenerated by PeakRDL-uvm
package soc_ifc_reg_uvm;
    `include "uvm_macros.svh"
    import uvm_pkg::*;
    `include "soc_ifc_reg_covergroups.svh"
    // Reg - soc_ifc_reg::CPTRA_HW_ERROR_FATAL
    class soc_ifc_reg__CPTRA_HW_ERROR_FATAL extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__CPTRA_HW_ERROR_FATAL_bit_cg iccm_ecc_unc_bit_cg[1];
        soc_ifc_reg__CPTRA_HW_ERROR_FATAL_bit_cg dccm_ecc_unc_bit_cg[1];
        soc_ifc_reg__CPTRA_HW_ERROR_FATAL_bit_cg nmi_pin_bit_cg[1];
        soc_ifc_reg__CPTRA_HW_ERROR_FATAL_bit_cg crypto_err_bit_cg[1];
        soc_ifc_reg__CPTRA_HW_ERROR_FATAL_bit_cg rsvd_bit_cg[28];
        soc_ifc_reg__CPTRA_HW_ERROR_FATAL_fld_cg fld_cg;
        rand uvm_reg_field iccm_ecc_unc;
        rand uvm_reg_field dccm_ecc_unc;
        rand uvm_reg_field nmi_pin;
        rand uvm_reg_field crypto_err;
        rand uvm_reg_field rsvd;

        function new(string name = "soc_ifc_reg__CPTRA_HW_ERROR_FATAL");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.iccm_ecc_unc = new("iccm_ecc_unc");
            this.iccm_ecc_unc.configure(this, 1, 0, "W1C", 1, 'h0, 1, 1, 0);
            this.dccm_ecc_unc = new("dccm_ecc_unc");
            this.dccm_ecc_unc.configure(this, 1, 1, "W1C", 1, 'h0, 1, 1, 0);
            this.nmi_pin = new("nmi_pin");
            this.nmi_pin.configure(this, 1, 2, "W1C", 1, 'h0, 1, 1, 0);
            this.crypto_err = new("crypto_err");
            this.crypto_err.configure(this, 1, 3, "W1C", 1, 'h0, 1, 1, 0);
            this.rsvd = new("rsvd");
            this.rsvd.configure(this, 28, 4, "RO", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(iccm_ecc_unc_bit_cg[bt]) iccm_ecc_unc_bit_cg[bt] = new();
                foreach(dccm_ecc_unc_bit_cg[bt]) dccm_ecc_unc_bit_cg[bt] = new();
                foreach(nmi_pin_bit_cg[bt]) nmi_pin_bit_cg[bt] = new();
                foreach(crypto_err_bit_cg[bt]) crypto_err_bit_cg[bt] = new();
                foreach(rsvd_bit_cg[bt]) rsvd_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__CPTRA_HW_ERROR_FATAL

    // Reg - soc_ifc_reg::CPTRA_HW_ERROR_NON_FATAL
    class soc_ifc_reg__CPTRA_HW_ERROR_NON_FATAL extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__CPTRA_HW_ERROR_NON_FATAL_bit_cg mbox_prot_no_lock_bit_cg[1];
        soc_ifc_reg__CPTRA_HW_ERROR_NON_FATAL_bit_cg mbox_prot_ooo_bit_cg[1];
        soc_ifc_reg__CPTRA_HW_ERROR_NON_FATAL_bit_cg mbox_ecc_unc_bit_cg[1];
        soc_ifc_reg__CPTRA_HW_ERROR_NON_FATAL_bit_cg rsvd_bit_cg[29];
        soc_ifc_reg__CPTRA_HW_ERROR_NON_FATAL_fld_cg fld_cg;
        rand uvm_reg_field mbox_prot_no_lock;
        rand uvm_reg_field mbox_prot_ooo;
        rand uvm_reg_field mbox_ecc_unc;
        rand uvm_reg_field rsvd;

        function new(string name = "soc_ifc_reg__CPTRA_HW_ERROR_NON_FATAL");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.mbox_prot_no_lock = new("mbox_prot_no_lock");
            this.mbox_prot_no_lock.configure(this, 1, 0, "W1C", 1, 'h0, 1, 1, 0);
            this.mbox_prot_ooo = new("mbox_prot_ooo");
            this.mbox_prot_ooo.configure(this, 1, 1, "W1C", 1, 'h0, 1, 1, 0);
            this.mbox_ecc_unc = new("mbox_ecc_unc");
            this.mbox_ecc_unc.configure(this, 1, 2, "W1C", 1, 'h0, 1, 1, 0);
            this.rsvd = new("rsvd");
            this.rsvd.configure(this, 29, 3, "RO", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(mbox_prot_no_lock_bit_cg[bt]) mbox_prot_no_lock_bit_cg[bt] = new();
                foreach(mbox_prot_ooo_bit_cg[bt]) mbox_prot_ooo_bit_cg[bt] = new();
                foreach(mbox_ecc_unc_bit_cg[bt]) mbox_ecc_unc_bit_cg[bt] = new();
                foreach(rsvd_bit_cg[bt]) rsvd_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__CPTRA_HW_ERROR_NON_FATAL

    // Reg - soc_ifc_reg::CPTRA_FW_ERROR_FATAL
    class soc_ifc_reg__CPTRA_FW_ERROR_FATAL extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__CPTRA_FW_ERROR_FATAL_bit_cg error_code_bit_cg[32];
        soc_ifc_reg__CPTRA_FW_ERROR_FATAL_fld_cg fld_cg;
        rand uvm_reg_field error_code;

        function new(string name = "soc_ifc_reg__CPTRA_FW_ERROR_FATAL");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.error_code = new("error_code");
            this.error_code.configure(this, 32, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(error_code_bit_cg[bt]) error_code_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__CPTRA_FW_ERROR_FATAL

    // Reg - soc_ifc_reg::CPTRA_FW_ERROR_NON_FATAL
    class soc_ifc_reg__CPTRA_FW_ERROR_NON_FATAL extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__CPTRA_FW_ERROR_NON_FATAL_bit_cg error_code_bit_cg[32];
        soc_ifc_reg__CPTRA_FW_ERROR_NON_FATAL_fld_cg fld_cg;
        rand uvm_reg_field error_code;

        function new(string name = "soc_ifc_reg__CPTRA_FW_ERROR_NON_FATAL");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.error_code = new("error_code");
            this.error_code.configure(this, 32, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(error_code_bit_cg[bt]) error_code_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__CPTRA_FW_ERROR_NON_FATAL

    // Reg - soc_ifc_reg::CPTRA_HW_ERROR_ENC
    class soc_ifc_reg__CPTRA_HW_ERROR_ENC extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__CPTRA_HW_ERROR_ENC_bit_cg error_code_bit_cg[32];
        soc_ifc_reg__CPTRA_HW_ERROR_ENC_fld_cg fld_cg;
        rand uvm_reg_field error_code;

        function new(string name = "soc_ifc_reg__CPTRA_HW_ERROR_ENC");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.error_code = new("error_code");
            this.error_code.configure(this, 32, 0, "RW", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(error_code_bit_cg[bt]) error_code_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__CPTRA_HW_ERROR_ENC

    // Reg - soc_ifc_reg::CPTRA_FW_ERROR_ENC
    class soc_ifc_reg__CPTRA_FW_ERROR_ENC extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__CPTRA_FW_ERROR_ENC_bit_cg error_code_bit_cg[32];
        soc_ifc_reg__CPTRA_FW_ERROR_ENC_fld_cg fld_cg;
        rand uvm_reg_field error_code;

        function new(string name = "soc_ifc_reg__CPTRA_FW_ERROR_ENC");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.error_code = new("error_code");
            this.error_code.configure(this, 32, 0, "RW", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(error_code_bit_cg[bt]) error_code_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__CPTRA_FW_ERROR_ENC

    // Reg - soc_ifc_reg::CPTRA_FW_EXTENDED_ERROR_INFO
    class soc_ifc_reg__CPTRA_FW_EXTENDED_ERROR_INFO extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__CPTRA_FW_EXTENDED_ERROR_INFO_bit_cg error_info_bit_cg[32];
        soc_ifc_reg__CPTRA_FW_EXTENDED_ERROR_INFO_fld_cg fld_cg;
        rand uvm_reg_field error_info;

        function new(string name = "soc_ifc_reg__CPTRA_FW_EXTENDED_ERROR_INFO");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.error_info = new("error_info");
            this.error_info.configure(this, 32, 0, "RW", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(error_info_bit_cg[bt]) error_info_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__CPTRA_FW_EXTENDED_ERROR_INFO

    // Reg - soc_ifc_reg::CPTRA_BOOT_STATUS
    class soc_ifc_reg__CPTRA_BOOT_STATUS extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__CPTRA_BOOT_STATUS_bit_cg status_bit_cg[32];
        soc_ifc_reg__CPTRA_BOOT_STATUS_fld_cg fld_cg;
        rand uvm_reg_field status;

        function new(string name = "soc_ifc_reg__CPTRA_BOOT_STATUS");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.status = new("status");
            this.status.configure(this, 32, 0, "RW", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(status_bit_cg[bt]) status_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__CPTRA_BOOT_STATUS

    // Reg - soc_ifc_reg::CPTRA_FLOW_STATUS
    class soc_ifc_reg__CPTRA_FLOW_STATUS extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__CPTRA_FLOW_STATUS_bit_cg status_bit_cg[24];
        soc_ifc_reg__CPTRA_FLOW_STATUS_bit_cg idevid_csr_ready_bit_cg[1];
        soc_ifc_reg__CPTRA_FLOW_STATUS_bit_cg boot_fsm_ps_bit_cg[3];
        soc_ifc_reg__CPTRA_FLOW_STATUS_bit_cg ready_for_mb_processing_bit_cg[1];
        soc_ifc_reg__CPTRA_FLOW_STATUS_bit_cg ready_for_runtime_bit_cg[1];
        soc_ifc_reg__CPTRA_FLOW_STATUS_bit_cg ready_for_fuses_bit_cg[1];
        soc_ifc_reg__CPTRA_FLOW_STATUS_bit_cg mailbox_flow_done_bit_cg[1];
        soc_ifc_reg__CPTRA_FLOW_STATUS_fld_cg fld_cg;
        rand uvm_reg_field status;
        rand uvm_reg_field idevid_csr_ready;
        rand uvm_reg_field boot_fsm_ps;
        rand uvm_reg_field ready_for_mb_processing;
        rand uvm_reg_field ready_for_runtime;
        rand uvm_reg_field ready_for_fuses;
        rand uvm_reg_field mailbox_flow_done;

        function new(string name = "soc_ifc_reg__CPTRA_FLOW_STATUS");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.status = new("status");
            this.status.configure(this, 24, 0, "RW", 0, 'h0, 1, 1, 0);
            this.idevid_csr_ready = new("idevid_csr_ready");
            this.idevid_csr_ready.configure(this, 1, 24, "RW", 0, 'h0, 1, 1, 0);
            this.boot_fsm_ps = new("boot_fsm_ps");
            this.boot_fsm_ps.configure(this, 3, 25, "RO", 1, 'h0, 0, 1, 0);
            this.ready_for_mb_processing = new("ready_for_mb_processing");
            this.ready_for_mb_processing.configure(this, 1, 28, "RW", 0, 'h0, 1, 1, 0);
            this.ready_for_runtime = new("ready_for_runtime");
            this.ready_for_runtime.configure(this, 1, 29, "RW", 0, 'h0, 1, 1, 0);
            this.ready_for_fuses = new("ready_for_fuses");
            this.ready_for_fuses.configure(this, 1, 30, "RO", 1, 'h0, 0, 1, 0);
            this.mailbox_flow_done = new("mailbox_flow_done");
            this.mailbox_flow_done.configure(this, 1, 31, "RW", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(status_bit_cg[bt]) status_bit_cg[bt] = new();
                foreach(idevid_csr_ready_bit_cg[bt]) idevid_csr_ready_bit_cg[bt] = new();
                foreach(boot_fsm_ps_bit_cg[bt]) boot_fsm_ps_bit_cg[bt] = new();
                foreach(ready_for_mb_processing_bit_cg[bt]) ready_for_mb_processing_bit_cg[bt] = new();
                foreach(ready_for_runtime_bit_cg[bt]) ready_for_runtime_bit_cg[bt] = new();
                foreach(ready_for_fuses_bit_cg[bt]) ready_for_fuses_bit_cg[bt] = new();
                foreach(mailbox_flow_done_bit_cg[bt]) mailbox_flow_done_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__CPTRA_FLOW_STATUS

    // Reg - soc_ifc_reg::CPTRA_RESET_REASON
    class soc_ifc_reg__CPTRA_RESET_REASON extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__CPTRA_RESET_REASON_bit_cg FW_UPD_RESET_bit_cg[1];
        soc_ifc_reg__CPTRA_RESET_REASON_bit_cg WARM_RESET_bit_cg[1];
        soc_ifc_reg__CPTRA_RESET_REASON_fld_cg fld_cg;
        rand uvm_reg_field FW_UPD_RESET;
        rand uvm_reg_field WARM_RESET;

        function new(string name = "soc_ifc_reg__CPTRA_RESET_REASON");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.FW_UPD_RESET = new("FW_UPD_RESET");
            this.FW_UPD_RESET.configure(this, 1, 0, "RO", 1, 'h0, 1, 1, 0);
            this.WARM_RESET = new("WARM_RESET");
            this.WARM_RESET.configure(this, 1, 1, "RO", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(FW_UPD_RESET_bit_cg[bt]) FW_UPD_RESET_bit_cg[bt] = new();
                foreach(WARM_RESET_bit_cg[bt]) WARM_RESET_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__CPTRA_RESET_REASON

    // Reg - soc_ifc_reg::CPTRA_SECURITY_STATE
    class soc_ifc_reg__CPTRA_SECURITY_STATE extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__CPTRA_SECURITY_STATE_bit_cg device_lifecycle_bit_cg[2];
        soc_ifc_reg__CPTRA_SECURITY_STATE_bit_cg debug_locked_bit_cg[1];
        soc_ifc_reg__CPTRA_SECURITY_STATE_bit_cg scan_mode_bit_cg[1];
        soc_ifc_reg__CPTRA_SECURITY_STATE_bit_cg rsvd_bit_cg[28];
        soc_ifc_reg__CPTRA_SECURITY_STATE_fld_cg fld_cg;
        rand uvm_reg_field device_lifecycle;
        rand uvm_reg_field debug_locked;
        rand uvm_reg_field scan_mode;
        rand uvm_reg_field rsvd;

        function new(string name = "soc_ifc_reg__CPTRA_SECURITY_STATE");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.device_lifecycle = new("device_lifecycle");
            this.device_lifecycle.configure(this, 2, 0, "RO", 1, 'h0, 1, 1, 0);
            this.debug_locked = new("debug_locked");
            this.debug_locked.configure(this, 1, 2, "RO", 1, 'h0, 1, 1, 0);
            this.scan_mode = new("scan_mode");
            this.scan_mode.configure(this, 1, 3, "RO", 1, 'h0, 1, 1, 0);
            this.rsvd = new("rsvd");
            this.rsvd.configure(this, 28, 4, "RO", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(device_lifecycle_bit_cg[bt]) device_lifecycle_bit_cg[bt] = new();
                foreach(debug_locked_bit_cg[bt]) debug_locked_bit_cg[bt] = new();
                foreach(scan_mode_bit_cg[bt]) scan_mode_bit_cg[bt] = new();
                foreach(rsvd_bit_cg[bt]) rsvd_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__CPTRA_SECURITY_STATE

    // Reg - soc_ifc_reg::CPTRA_MBOX_VALID_AXI_USER
    class soc_ifc_reg__CPTRA_MBOX_VALID_AXI_USER extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__CPTRA_MBOX_VALID_AXI_USER_bit_cg AXI_USER_bit_cg[32];
        soc_ifc_reg__CPTRA_MBOX_VALID_AXI_USER_fld_cg fld_cg;
        rand uvm_reg_field AXI_USER;

        function new(string name = "soc_ifc_reg__CPTRA_MBOX_VALID_AXI_USER");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.AXI_USER = new("AXI_USER");
            this.AXI_USER.configure(this, 32, 0, "RW", 0, 'hffffffff, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(AXI_USER_bit_cg[bt]) AXI_USER_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__CPTRA_MBOX_VALID_AXI_USER

    // Reg - soc_ifc_reg::CPTRA_MBOX_AXI_USER_LOCK
    class soc_ifc_reg__CPTRA_MBOX_AXI_USER_LOCK extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__CPTRA_MBOX_AXI_USER_LOCK_bit_cg LOCK_bit_cg[1];
        soc_ifc_reg__CPTRA_MBOX_AXI_USER_LOCK_fld_cg fld_cg;
        rand uvm_reg_field LOCK;

        function new(string name = "soc_ifc_reg__CPTRA_MBOX_AXI_USER_LOCK");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.LOCK = new("LOCK");
            this.LOCK.configure(this, 1, 0, "RW", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(LOCK_bit_cg[bt]) LOCK_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__CPTRA_MBOX_AXI_USER_LOCK

    // Reg - soc_ifc_reg::CPTRA_TRNG_VALID_AXI_USER
    class soc_ifc_reg__CPTRA_TRNG_VALID_AXI_USER extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__CPTRA_TRNG_VALID_AXI_USER_bit_cg AXI_USER_bit_cg[32];
        soc_ifc_reg__CPTRA_TRNG_VALID_AXI_USER_fld_cg fld_cg;
        rand uvm_reg_field AXI_USER;

        function new(string name = "soc_ifc_reg__CPTRA_TRNG_VALID_AXI_USER");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.AXI_USER = new("AXI_USER");
            this.AXI_USER.configure(this, 32, 0, "RW", 0, 'hffffffff, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(AXI_USER_bit_cg[bt]) AXI_USER_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__CPTRA_TRNG_VALID_AXI_USER

    // Reg - soc_ifc_reg::CPTRA_TRNG_AXI_USER_LOCK
    class soc_ifc_reg__CPTRA_TRNG_AXI_USER_LOCK extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__CPTRA_TRNG_AXI_USER_LOCK_bit_cg LOCK_bit_cg[1];
        soc_ifc_reg__CPTRA_TRNG_AXI_USER_LOCK_fld_cg fld_cg;
        rand uvm_reg_field LOCK;

        function new(string name = "soc_ifc_reg__CPTRA_TRNG_AXI_USER_LOCK");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.LOCK = new("LOCK");
            this.LOCK.configure(this, 1, 0, "RW", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(LOCK_bit_cg[bt]) LOCK_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__CPTRA_TRNG_AXI_USER_LOCK

    // Reg - soc_ifc_reg::CPTRA_TRNG_DATA
    class soc_ifc_reg__CPTRA_TRNG_DATA extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__CPTRA_TRNG_DATA_bit_cg DATA_bit_cg[32];
        soc_ifc_reg__CPTRA_TRNG_DATA_fld_cg fld_cg;
        rand uvm_reg_field DATA;

        function new(string name = "soc_ifc_reg__CPTRA_TRNG_DATA");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.DATA = new("DATA");
            this.DATA.configure(this, 32, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(DATA_bit_cg[bt]) DATA_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__CPTRA_TRNG_DATA

    // Reg - soc_ifc_reg::CPTRA_TRNG_CTRL
    class soc_ifc_reg__CPTRA_TRNG_CTRL extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__CPTRA_TRNG_CTRL_bit_cg clear_bit_cg[1];
        soc_ifc_reg__CPTRA_TRNG_CTRL_fld_cg fld_cg;
        rand uvm_reg_field clear;

        function new(string name = "soc_ifc_reg__CPTRA_TRNG_CTRL");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.clear = new("clear");
            this.clear.configure(this, 1, 0, "RW", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(clear_bit_cg[bt]) clear_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__CPTRA_TRNG_CTRL

    // Reg - soc_ifc_reg::CPTRA_TRNG_STATUS
    class soc_ifc_reg__CPTRA_TRNG_STATUS extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__CPTRA_TRNG_STATUS_bit_cg DATA_REQ_bit_cg[1];
        soc_ifc_reg__CPTRA_TRNG_STATUS_bit_cg DATA_WR_DONE_bit_cg[1];
        soc_ifc_reg__CPTRA_TRNG_STATUS_fld_cg fld_cg;
        rand uvm_reg_field DATA_REQ;
        rand uvm_reg_field DATA_WR_DONE;

        function new(string name = "soc_ifc_reg__CPTRA_TRNG_STATUS");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.DATA_REQ = new("DATA_REQ");
            this.DATA_REQ.configure(this, 1, 0, "RW", 0, 'h0, 1, 1, 0);
            this.DATA_WR_DONE = new("DATA_WR_DONE");
            this.DATA_WR_DONE.configure(this, 1, 1, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(DATA_REQ_bit_cg[bt]) DATA_REQ_bit_cg[bt] = new();
                foreach(DATA_WR_DONE_bit_cg[bt]) DATA_WR_DONE_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__CPTRA_TRNG_STATUS

    // Reg - soc_ifc_reg::CPTRA_FUSE_WR_DONE
    class soc_ifc_reg__CPTRA_FUSE_WR_DONE extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__CPTRA_FUSE_WR_DONE_bit_cg done_bit_cg[1];
        soc_ifc_reg__CPTRA_FUSE_WR_DONE_fld_cg fld_cg;
        rand uvm_reg_field done;

        function new(string name = "soc_ifc_reg__CPTRA_FUSE_WR_DONE");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.done = new("done");
            this.done.configure(this, 1, 0, "RW", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(done_bit_cg[bt]) done_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__CPTRA_FUSE_WR_DONE

    // Reg - soc_ifc_reg::CPTRA_TIMER_CONFIG
    class soc_ifc_reg__CPTRA_TIMER_CONFIG extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__CPTRA_TIMER_CONFIG_bit_cg clk_period_bit_cg[32];
        soc_ifc_reg__CPTRA_TIMER_CONFIG_fld_cg fld_cg;
        rand uvm_reg_field clk_period;

        function new(string name = "soc_ifc_reg__CPTRA_TIMER_CONFIG");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.clk_period = new("clk_period");
            this.clk_period.configure(this, 32, 0, "RW", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(clk_period_bit_cg[bt]) clk_period_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__CPTRA_TIMER_CONFIG

    // Reg - soc_ifc_reg::CPTRA_BOOTFSM_GO
    class soc_ifc_reg__CPTRA_BOOTFSM_GO extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__CPTRA_BOOTFSM_GO_bit_cg GO_bit_cg[1];
        soc_ifc_reg__CPTRA_BOOTFSM_GO_fld_cg fld_cg;
        rand uvm_reg_field GO;

        function new(string name = "soc_ifc_reg__CPTRA_BOOTFSM_GO");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.GO = new("GO");
            this.GO.configure(this, 1, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(GO_bit_cg[bt]) GO_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__CPTRA_BOOTFSM_GO

    // Reg - soc_ifc_reg::CPTRA_DBG_MANUF_SERVICE_REG
    class soc_ifc_reg__CPTRA_DBG_MANUF_SERVICE_REG extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__CPTRA_DBG_MANUF_SERVICE_REG_bit_cg DATA_bit_cg[32];
        soc_ifc_reg__CPTRA_DBG_MANUF_SERVICE_REG_fld_cg fld_cg;
        rand uvm_reg_field DATA;

        function new(string name = "soc_ifc_reg__CPTRA_DBG_MANUF_SERVICE_REG");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.DATA = new("DATA");
            this.DATA.configure(this, 32, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(DATA_bit_cg[bt]) DATA_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__CPTRA_DBG_MANUF_SERVICE_REG

    // Reg - soc_ifc_reg::CPTRA_CLK_GATING_EN
    class soc_ifc_reg__CPTRA_CLK_GATING_EN extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__CPTRA_CLK_GATING_EN_bit_cg clk_gating_en_bit_cg[1];
        soc_ifc_reg__CPTRA_CLK_GATING_EN_fld_cg fld_cg;
        rand uvm_reg_field clk_gating_en;

        function new(string name = "soc_ifc_reg__CPTRA_CLK_GATING_EN");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.clk_gating_en = new("clk_gating_en");
            this.clk_gating_en.configure(this, 1, 0, "RW", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(clk_gating_en_bit_cg[bt]) clk_gating_en_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__CPTRA_CLK_GATING_EN

    // Reg - soc_ifc_reg::CPTRA_GENERIC_INPUT_WIRES
    class soc_ifc_reg__CPTRA_GENERIC_INPUT_WIRES extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__CPTRA_GENERIC_INPUT_WIRES_bit_cg generic_wires_bit_cg[32];
        soc_ifc_reg__CPTRA_GENERIC_INPUT_WIRES_fld_cg fld_cg;
        rand uvm_reg_field generic_wires;

        function new(string name = "soc_ifc_reg__CPTRA_GENERIC_INPUT_WIRES");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.generic_wires = new("generic_wires");
            this.generic_wires.configure(this, 32, 0, "RO", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(generic_wires_bit_cg[bt]) generic_wires_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__CPTRA_GENERIC_INPUT_WIRES

    // Reg - soc_ifc_reg::CPTRA_GENERIC_OUTPUT_WIRES
    class soc_ifc_reg__CPTRA_GENERIC_OUTPUT_WIRES extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__CPTRA_GENERIC_OUTPUT_WIRES_bit_cg generic_wires_bit_cg[32];
        soc_ifc_reg__CPTRA_GENERIC_OUTPUT_WIRES_fld_cg fld_cg;
        rand uvm_reg_field generic_wires;

        function new(string name = "soc_ifc_reg__CPTRA_GENERIC_OUTPUT_WIRES");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.generic_wires = new("generic_wires");
            this.generic_wires.configure(this, 32, 0, "RW", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(generic_wires_bit_cg[bt]) generic_wires_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__CPTRA_GENERIC_OUTPUT_WIRES

    // Reg - soc_ifc_reg::CPTRA_HW_REV_ID
    class soc_ifc_reg__CPTRA_HW_REV_ID extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__CPTRA_HW_REV_ID_bit_cg CPTRA_GENERATION_bit_cg[16];
        soc_ifc_reg__CPTRA_HW_REV_ID_bit_cg SOC_STEPPING_ID_bit_cg[16];
        soc_ifc_reg__CPTRA_HW_REV_ID_fld_cg fld_cg;
        rand uvm_reg_field CPTRA_GENERATION;
        rand uvm_reg_field SOC_STEPPING_ID;

        function new(string name = "soc_ifc_reg__CPTRA_HW_REV_ID");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.CPTRA_GENERATION = new("CPTRA_GENERATION");
            this.CPTRA_GENERATION.configure(this, 16, 0, "RO", 0, 'h11, 1, 1, 0);
            this.SOC_STEPPING_ID = new("SOC_STEPPING_ID");
            this.SOC_STEPPING_ID.configure(this, 16, 16, "RO", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(CPTRA_GENERATION_bit_cg[bt]) CPTRA_GENERATION_bit_cg[bt] = new();
                foreach(SOC_STEPPING_ID_bit_cg[bt]) SOC_STEPPING_ID_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__CPTRA_HW_REV_ID

    // Reg - soc_ifc_reg::CPTRA_FW_REV_ID
    class soc_ifc_reg__CPTRA_FW_REV_ID extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__CPTRA_FW_REV_ID_bit_cg REV_ID_bit_cg[32];
        soc_ifc_reg__CPTRA_FW_REV_ID_fld_cg fld_cg;
        rand uvm_reg_field REV_ID;

        function new(string name = "soc_ifc_reg__CPTRA_FW_REV_ID");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.REV_ID = new("REV_ID");
            this.REV_ID.configure(this, 32, 0, "RW", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(REV_ID_bit_cg[bt]) REV_ID_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__CPTRA_FW_REV_ID

    // Reg - soc_ifc_reg::CPTRA_HW_CONFIG
    class soc_ifc_reg__CPTRA_HW_CONFIG extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__CPTRA_HW_CONFIG_bit_cg iTRNG_en_bit_cg[1];
        soc_ifc_reg__CPTRA_HW_CONFIG_bit_cg RSVD_en_bit_cg[3];
        soc_ifc_reg__CPTRA_HW_CONFIG_bit_cg LMS_acc_en_bit_cg[1];
        soc_ifc_reg__CPTRA_HW_CONFIG_bit_cg ACTIVE_MODE_en_bit_cg[1];
        soc_ifc_reg__CPTRA_HW_CONFIG_fld_cg fld_cg;
        rand uvm_reg_field iTRNG_en;
        rand uvm_reg_field RSVD_en;
        rand uvm_reg_field LMS_acc_en;
        rand uvm_reg_field ACTIVE_MODE_en;

        function new(string name = "soc_ifc_reg__CPTRA_HW_CONFIG");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.iTRNG_en = new("iTRNG_en");
            this.iTRNG_en.configure(this, 1, 0, "RO", 1, 'h0, 0, 1, 0);
            this.RSVD_en = new("RSVD_en");
            this.RSVD_en.configure(this, 3, 1, "RO", 1, 'h0, 0, 1, 0);
            this.LMS_acc_en = new("LMS_acc_en");
            this.LMS_acc_en.configure(this, 1, 4, "RO", 1, 'h0, 0, 1, 0);
            this.ACTIVE_MODE_en = new("ACTIVE_MODE_en");
            this.ACTIVE_MODE_en.configure(this, 1, 5, "RO", 1, 'h0, 0, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(iTRNG_en_bit_cg[bt]) iTRNG_en_bit_cg[bt] = new();
                foreach(RSVD_en_bit_cg[bt]) RSVD_en_bit_cg[bt] = new();
                foreach(LMS_acc_en_bit_cg[bt]) LMS_acc_en_bit_cg[bt] = new();
                foreach(ACTIVE_MODE_en_bit_cg[bt]) ACTIVE_MODE_en_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__CPTRA_HW_CONFIG

    // Reg - soc_ifc_reg::CPTRA_WDT_TIMER1_EN
    class soc_ifc_reg__CPTRA_WDT_TIMER1_EN extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__CPTRA_WDT_TIMER1_EN_bit_cg timer1_en_bit_cg[1];
        soc_ifc_reg__CPTRA_WDT_TIMER1_EN_fld_cg fld_cg;
        rand uvm_reg_field timer1_en;

        function new(string name = "soc_ifc_reg__CPTRA_WDT_TIMER1_EN");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.timer1_en = new("timer1_en");
            this.timer1_en.configure(this, 1, 0, "RW", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(timer1_en_bit_cg[bt]) timer1_en_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__CPTRA_WDT_TIMER1_EN

    // Reg - soc_ifc_reg::CPTRA_WDT_TIMER1_CTRL
    class soc_ifc_reg__CPTRA_WDT_TIMER1_CTRL extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__CPTRA_WDT_TIMER1_CTRL_bit_cg timer1_restart_bit_cg[1];
        soc_ifc_reg__CPTRA_WDT_TIMER1_CTRL_fld_cg fld_cg;
        rand uvm_reg_field timer1_restart;

        function new(string name = "soc_ifc_reg__CPTRA_WDT_TIMER1_CTRL");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.timer1_restart = new("timer1_restart");
            this.timer1_restart.configure(this, 1, 0, "RW", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(timer1_restart_bit_cg[bt]) timer1_restart_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__CPTRA_WDT_TIMER1_CTRL

    // Reg - soc_ifc_reg::CPTRA_WDT_TIMER1_TIMEOUT_PERIOD
    class soc_ifc_reg__CPTRA_WDT_TIMER1_TIMEOUT_PERIOD extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__CPTRA_WDT_TIMER1_TIMEOUT_PERIOD_bit_cg timer1_timeout_period_bit_cg[32];
        soc_ifc_reg__CPTRA_WDT_TIMER1_TIMEOUT_PERIOD_fld_cg fld_cg;
        rand uvm_reg_field timer1_timeout_period;

        function new(string name = "soc_ifc_reg__CPTRA_WDT_TIMER1_TIMEOUT_PERIOD");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.timer1_timeout_period = new("timer1_timeout_period");
            this.timer1_timeout_period.configure(this, 32, 0, "RW", 0, 'hffffffff, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(timer1_timeout_period_bit_cg[bt]) timer1_timeout_period_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__CPTRA_WDT_TIMER1_TIMEOUT_PERIOD

    // Reg - soc_ifc_reg::CPTRA_WDT_TIMER2_EN
    class soc_ifc_reg__CPTRA_WDT_TIMER2_EN extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__CPTRA_WDT_TIMER2_EN_bit_cg timer2_en_bit_cg[1];
        soc_ifc_reg__CPTRA_WDT_TIMER2_EN_fld_cg fld_cg;
        rand uvm_reg_field timer2_en;

        function new(string name = "soc_ifc_reg__CPTRA_WDT_TIMER2_EN");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.timer2_en = new("timer2_en");
            this.timer2_en.configure(this, 1, 0, "RW", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(timer2_en_bit_cg[bt]) timer2_en_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__CPTRA_WDT_TIMER2_EN

    // Reg - soc_ifc_reg::CPTRA_WDT_TIMER2_CTRL
    class soc_ifc_reg__CPTRA_WDT_TIMER2_CTRL extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__CPTRA_WDT_TIMER2_CTRL_bit_cg timer2_restart_bit_cg[1];
        soc_ifc_reg__CPTRA_WDT_TIMER2_CTRL_fld_cg fld_cg;
        rand uvm_reg_field timer2_restart;

        function new(string name = "soc_ifc_reg__CPTRA_WDT_TIMER2_CTRL");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.timer2_restart = new("timer2_restart");
            this.timer2_restart.configure(this, 1, 0, "RW", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(timer2_restart_bit_cg[bt]) timer2_restart_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__CPTRA_WDT_TIMER2_CTRL

    // Reg - soc_ifc_reg::CPTRA_WDT_TIMER2_TIMEOUT_PERIOD
    class soc_ifc_reg__CPTRA_WDT_TIMER2_TIMEOUT_PERIOD extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__CPTRA_WDT_TIMER2_TIMEOUT_PERIOD_bit_cg timer2_timeout_period_bit_cg[32];
        soc_ifc_reg__CPTRA_WDT_TIMER2_TIMEOUT_PERIOD_fld_cg fld_cg;
        rand uvm_reg_field timer2_timeout_period;

        function new(string name = "soc_ifc_reg__CPTRA_WDT_TIMER2_TIMEOUT_PERIOD");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.timer2_timeout_period = new("timer2_timeout_period");
            this.timer2_timeout_period.configure(this, 32, 0, "RW", 0, 'hffffffff, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(timer2_timeout_period_bit_cg[bt]) timer2_timeout_period_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__CPTRA_WDT_TIMER2_TIMEOUT_PERIOD

    // Reg - soc_ifc_reg::CPTRA_WDT_STATUS
    class soc_ifc_reg__CPTRA_WDT_STATUS extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__CPTRA_WDT_STATUS_bit_cg t1_timeout_bit_cg[1];
        soc_ifc_reg__CPTRA_WDT_STATUS_bit_cg t2_timeout_bit_cg[1];
        soc_ifc_reg__CPTRA_WDT_STATUS_fld_cg fld_cg;
        rand uvm_reg_field t1_timeout;
        rand uvm_reg_field t2_timeout;

        function new(string name = "soc_ifc_reg__CPTRA_WDT_STATUS");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.t1_timeout = new("t1_timeout");
            this.t1_timeout.configure(this, 1, 0, "RW", 1, 'h0, 1, 1, 0);
            this.t2_timeout = new("t2_timeout");
            this.t2_timeout.configure(this, 1, 1, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(t1_timeout_bit_cg[bt]) t1_timeout_bit_cg[bt] = new();
                foreach(t2_timeout_bit_cg[bt]) t2_timeout_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__CPTRA_WDT_STATUS

    // Reg - soc_ifc_reg::CPTRA_FUSE_VALID_AXI_USER
    class soc_ifc_reg__CPTRA_FUSE_VALID_AXI_USER extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__CPTRA_FUSE_VALID_AXI_USER_bit_cg AXI_USER_bit_cg[32];
        soc_ifc_reg__CPTRA_FUSE_VALID_AXI_USER_fld_cg fld_cg;
        rand uvm_reg_field AXI_USER;

        function new(string name = "soc_ifc_reg__CPTRA_FUSE_VALID_AXI_USER");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.AXI_USER = new("AXI_USER");
            this.AXI_USER.configure(this, 32, 0, "RW", 0, 'hffffffff, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(AXI_USER_bit_cg[bt]) AXI_USER_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__CPTRA_FUSE_VALID_AXI_USER

    // Reg - soc_ifc_reg::CPTRA_FUSE_AXI_USER_LOCK
    class soc_ifc_reg__CPTRA_FUSE_AXI_USER_LOCK extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__CPTRA_FUSE_AXI_USER_LOCK_bit_cg LOCK_bit_cg[1];
        soc_ifc_reg__CPTRA_FUSE_AXI_USER_LOCK_fld_cg fld_cg;
        rand uvm_reg_field LOCK;

        function new(string name = "soc_ifc_reg__CPTRA_FUSE_AXI_USER_LOCK");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.LOCK = new("LOCK");
            this.LOCK.configure(this, 1, 0, "RW", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(LOCK_bit_cg[bt]) LOCK_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__CPTRA_FUSE_AXI_USER_LOCK

    // Reg - soc_ifc_reg::CPTRA_WDT_CFG
    class soc_ifc_reg__CPTRA_WDT_CFG extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__CPTRA_WDT_CFG_bit_cg TIMEOUT_bit_cg[32];
        soc_ifc_reg__CPTRA_WDT_CFG_fld_cg fld_cg;
        rand uvm_reg_field TIMEOUT;

        function new(string name = "soc_ifc_reg__CPTRA_WDT_CFG");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.TIMEOUT = new("TIMEOUT");
            this.TIMEOUT.configure(this, 32, 0, "RW", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(TIMEOUT_bit_cg[bt]) TIMEOUT_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__CPTRA_WDT_CFG

    // Reg - soc_ifc_reg::CPTRA_iTRNG_ENTROPY_CONFIG_0
    class soc_ifc_reg__CPTRA_iTRNG_ENTROPY_CONFIG_0 extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__CPTRA_iTRNG_ENTROPY_CONFIG_0_bit_cg low_threshold_bit_cg[16];
        soc_ifc_reg__CPTRA_iTRNG_ENTROPY_CONFIG_0_bit_cg high_threshold_bit_cg[16];
        soc_ifc_reg__CPTRA_iTRNG_ENTROPY_CONFIG_0_fld_cg fld_cg;
        rand uvm_reg_field low_threshold;
        rand uvm_reg_field high_threshold;

        function new(string name = "soc_ifc_reg__CPTRA_iTRNG_ENTROPY_CONFIG_0");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.low_threshold = new("low_threshold");
            this.low_threshold.configure(this, 16, 0, "RW", 0, 'h0, 1, 1, 0);
            this.high_threshold = new("high_threshold");
            this.high_threshold.configure(this, 16, 16, "RW", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(low_threshold_bit_cg[bt]) low_threshold_bit_cg[bt] = new();
                foreach(high_threshold_bit_cg[bt]) high_threshold_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__CPTRA_iTRNG_ENTROPY_CONFIG_0

    // Reg - soc_ifc_reg::CPTRA_iTRNG_ENTROPY_CONFIG_1
    class soc_ifc_reg__CPTRA_iTRNG_ENTROPY_CONFIG_1 extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__CPTRA_iTRNG_ENTROPY_CONFIG_1_bit_cg repetition_count_bit_cg[16];
        soc_ifc_reg__CPTRA_iTRNG_ENTROPY_CONFIG_1_bit_cg RSVD_bit_cg[16];
        soc_ifc_reg__CPTRA_iTRNG_ENTROPY_CONFIG_1_fld_cg fld_cg;
        rand uvm_reg_field repetition_count;
        rand uvm_reg_field RSVD;

        function new(string name = "soc_ifc_reg__CPTRA_iTRNG_ENTROPY_CONFIG_1");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.repetition_count = new("repetition_count");
            this.repetition_count.configure(this, 16, 0, "RW", 0, 'h0, 1, 1, 0);
            this.RSVD = new("RSVD");
            this.RSVD.configure(this, 16, 16, "RW", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(repetition_count_bit_cg[bt]) repetition_count_bit_cg[bt] = new();
                foreach(RSVD_bit_cg[bt]) RSVD_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__CPTRA_iTRNG_ENTROPY_CONFIG_1

    // Reg - soc_ifc_reg::CPTRA_RSVD_REG
    class soc_ifc_reg__CPTRA_RSVD_REG extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__CPTRA_RSVD_REG_bit_cg RSVD_bit_cg[32];
        soc_ifc_reg__CPTRA_RSVD_REG_fld_cg fld_cg;
        rand uvm_reg_field RSVD;

        function new(string name = "soc_ifc_reg__CPTRA_RSVD_REG");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.RSVD = new("RSVD");
            this.RSVD.configure(this, 32, 0, "RW", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(RSVD_bit_cg[bt]) RSVD_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__CPTRA_RSVD_REG

    // Reg - soc_ifc_reg::CPTRA_HW_CAPABILITIES
    class soc_ifc_reg__CPTRA_HW_CAPABILITIES extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__CPTRA_HW_CAPABILITIES_bit_cg cap_bit_cg[32];
        soc_ifc_reg__CPTRA_HW_CAPABILITIES_fld_cg fld_cg;
        rand uvm_reg_field cap;

        function new(string name = "soc_ifc_reg__CPTRA_HW_CAPABILITIES");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.cap = new("cap");
            this.cap.configure(this, 32, 0, "RW", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(cap_bit_cg[bt]) cap_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__CPTRA_HW_CAPABILITIES

    // Reg - soc_ifc_reg::CPTRA_FW_CAPABILITIES
    class soc_ifc_reg__CPTRA_FW_CAPABILITIES extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__CPTRA_FW_CAPABILITIES_bit_cg cap_bit_cg[32];
        soc_ifc_reg__CPTRA_FW_CAPABILITIES_fld_cg fld_cg;
        rand uvm_reg_field cap;

        function new(string name = "soc_ifc_reg__CPTRA_FW_CAPABILITIES");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.cap = new("cap");
            this.cap.configure(this, 32, 0, "RW", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(cap_bit_cg[bt]) cap_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__CPTRA_FW_CAPABILITIES

    // Reg - soc_ifc_reg::CPTRA_CAP_LOCK
    class soc_ifc_reg__CPTRA_CAP_LOCK extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__CPTRA_CAP_LOCK_bit_cg lock_bit_cg[1];
        soc_ifc_reg__CPTRA_CAP_LOCK_fld_cg fld_cg;
        rand uvm_reg_field lock;

        function new(string name = "soc_ifc_reg__CPTRA_CAP_LOCK");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.lock = new("lock");
            this.lock.configure(this, 1, 0, "RW", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(lock_bit_cg[bt]) lock_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__CPTRA_CAP_LOCK

    // Reg - soc_ifc_reg::CPTRA_OWNER_PK_HASH
    class soc_ifc_reg__CPTRA_OWNER_PK_HASH extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__CPTRA_OWNER_PK_HASH_bit_cg hash_bit_cg[32];
        soc_ifc_reg__CPTRA_OWNER_PK_HASH_fld_cg fld_cg;
        rand uvm_reg_field hash;

        function new(string name = "soc_ifc_reg__CPTRA_OWNER_PK_HASH");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.hash = new("hash");
            this.hash.configure(this, 32, 0, "RW", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(hash_bit_cg[bt]) hash_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__CPTRA_OWNER_PK_HASH

    // Reg - soc_ifc_reg::CPTRA_OWNER_PK_HASH_LOCK
    class soc_ifc_reg__CPTRA_OWNER_PK_HASH_LOCK extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__CPTRA_OWNER_PK_HASH_LOCK_bit_cg lock_bit_cg[1];
        soc_ifc_reg__CPTRA_OWNER_PK_HASH_LOCK_fld_cg fld_cg;
        rand uvm_reg_field lock;

        function new(string name = "soc_ifc_reg__CPTRA_OWNER_PK_HASH_LOCK");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.lock = new("lock");
            this.lock.configure(this, 1, 0, "RW", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(lock_bit_cg[bt]) lock_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__CPTRA_OWNER_PK_HASH_LOCK

    // Reg - soc_ifc_reg::fuse_uds_seed
    class soc_ifc_reg__fuse_uds_seed extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__fuse_uds_seed_bit_cg seed_bit_cg[32];
        soc_ifc_reg__fuse_uds_seed_fld_cg fld_cg;
        rand uvm_reg_field seed;

        function new(string name = "soc_ifc_reg__fuse_uds_seed");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.seed = new("seed");
            this.seed.configure(this, 32, 0, "WO1", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(seed_bit_cg[bt]) seed_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__fuse_uds_seed

    // Reg - soc_ifc_reg::fuse_field_entropy
    class soc_ifc_reg__fuse_field_entropy extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__fuse_field_entropy_bit_cg seed_bit_cg[32];
        soc_ifc_reg__fuse_field_entropy_fld_cg fld_cg;
        rand uvm_reg_field seed;

        function new(string name = "soc_ifc_reg__fuse_field_entropy");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.seed = new("seed");
            this.seed.configure(this, 32, 0, "WO1", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(seed_bit_cg[bt]) seed_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__fuse_field_entropy

    // Reg - soc_ifc_reg::fuse_key_manifest_pk_hash
    class soc_ifc_reg__fuse_key_manifest_pk_hash extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__fuse_key_manifest_pk_hash_bit_cg hash_bit_cg[32];
        soc_ifc_reg__fuse_key_manifest_pk_hash_fld_cg fld_cg;
        rand uvm_reg_field hash;

        function new(string name = "soc_ifc_reg__fuse_key_manifest_pk_hash");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.hash = new("hash");
            this.hash.configure(this, 32, 0, "RW", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(hash_bit_cg[bt]) hash_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__fuse_key_manifest_pk_hash

    // Reg - soc_ifc_reg::fuse_key_manifest_pk_hash_mask
    class soc_ifc_reg__fuse_key_manifest_pk_hash_mask extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__fuse_key_manifest_pk_hash_mask_bit_cg mask_bit_cg[4];
        soc_ifc_reg__fuse_key_manifest_pk_hash_mask_fld_cg fld_cg;
        rand uvm_reg_field mask;

        function new(string name = "soc_ifc_reg__fuse_key_manifest_pk_hash_mask");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.mask = new("mask");
            this.mask.configure(this, 4, 0, "RW", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(mask_bit_cg[bt]) mask_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__fuse_key_manifest_pk_hash_mask

    // Reg - soc_ifc_reg::fuse_fmc_key_manifest_svn
    class soc_ifc_reg__fuse_fmc_key_manifest_svn extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__fuse_fmc_key_manifest_svn_bit_cg svn_bit_cg[32];
        soc_ifc_reg__fuse_fmc_key_manifest_svn_fld_cg fld_cg;
        rand uvm_reg_field svn;

        function new(string name = "soc_ifc_reg__fuse_fmc_key_manifest_svn");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.svn = new("svn");
            this.svn.configure(this, 32, 0, "RW", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(svn_bit_cg[bt]) svn_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__fuse_fmc_key_manifest_svn

    // Reg - soc_ifc_reg::fuse_runtime_svn
    class soc_ifc_reg__fuse_runtime_svn extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__fuse_runtime_svn_bit_cg svn_bit_cg[32];
        soc_ifc_reg__fuse_runtime_svn_fld_cg fld_cg;
        rand uvm_reg_field svn;

        function new(string name = "soc_ifc_reg__fuse_runtime_svn");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.svn = new("svn");
            this.svn.configure(this, 32, 0, "RW", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(svn_bit_cg[bt]) svn_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__fuse_runtime_svn

    // Reg - soc_ifc_reg::fuse_anti_rollback_disable
    class soc_ifc_reg__fuse_anti_rollback_disable extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__fuse_anti_rollback_disable_bit_cg dis_bit_cg[1];
        soc_ifc_reg__fuse_anti_rollback_disable_fld_cg fld_cg;
        rand uvm_reg_field dis;

        function new(string name = "soc_ifc_reg__fuse_anti_rollback_disable");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.dis = new("dis");
            this.dis.configure(this, 1, 0, "RW", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(dis_bit_cg[bt]) dis_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__fuse_anti_rollback_disable

    // Reg - soc_ifc_reg::fuse_idevid_cert_attr
    class soc_ifc_reg__fuse_idevid_cert_attr extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__fuse_idevid_cert_attr_bit_cg cert_bit_cg[32];
        soc_ifc_reg__fuse_idevid_cert_attr_fld_cg fld_cg;
        rand uvm_reg_field cert;

        function new(string name = "soc_ifc_reg__fuse_idevid_cert_attr");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.cert = new("cert");
            this.cert.configure(this, 32, 0, "RW", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(cert_bit_cg[bt]) cert_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__fuse_idevid_cert_attr

    // Reg - soc_ifc_reg::fuse_idevid_manuf_hsm_id
    class soc_ifc_reg__fuse_idevid_manuf_hsm_id extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__fuse_idevid_manuf_hsm_id_bit_cg hsm_id_bit_cg[32];
        soc_ifc_reg__fuse_idevid_manuf_hsm_id_fld_cg fld_cg;
        rand uvm_reg_field hsm_id;

        function new(string name = "soc_ifc_reg__fuse_idevid_manuf_hsm_id");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.hsm_id = new("hsm_id");
            this.hsm_id.configure(this, 32, 0, "RW", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(hsm_id_bit_cg[bt]) hsm_id_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__fuse_idevid_manuf_hsm_id

    // Reg - soc_ifc_reg::fuse_lms_revocation
    class soc_ifc_reg__fuse_lms_revocation extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__fuse_lms_revocation_bit_cg lms_revocation_bit_cg[32];
        soc_ifc_reg__fuse_lms_revocation_fld_cg fld_cg;
        rand uvm_reg_field lms_revocation;

        function new(string name = "soc_ifc_reg__fuse_lms_revocation");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.lms_revocation = new("lms_revocation");
            this.lms_revocation.configure(this, 32, 0, "RW", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(lms_revocation_bit_cg[bt]) lms_revocation_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__fuse_lms_revocation

    // Reg - soc_ifc_reg::fuse_mldsa_revocation
    class soc_ifc_reg__fuse_mldsa_revocation extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__fuse_mldsa_revocation_bit_cg mldsa_revocation_bit_cg[4];
        soc_ifc_reg__fuse_mldsa_revocation_fld_cg fld_cg;
        rand uvm_reg_field mldsa_revocation;

        function new(string name = "soc_ifc_reg__fuse_mldsa_revocation");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.mldsa_revocation = new("mldsa_revocation");
            this.mldsa_revocation.configure(this, 4, 0, "RW", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(mldsa_revocation_bit_cg[bt]) mldsa_revocation_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__fuse_mldsa_revocation

    // Reg - soc_ifc_reg::fuse_soc_stepping_id
    class soc_ifc_reg__fuse_soc_stepping_id extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__fuse_soc_stepping_id_bit_cg soc_stepping_id_bit_cg[16];
        soc_ifc_reg__fuse_soc_stepping_id_fld_cg fld_cg;
        rand uvm_reg_field soc_stepping_id;

        function new(string name = "soc_ifc_reg__fuse_soc_stepping_id");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.soc_stepping_id = new("soc_stepping_id");
            this.soc_stepping_id.configure(this, 16, 0, "RW", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(soc_stepping_id_bit_cg[bt]) soc_stepping_id_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__fuse_soc_stepping_id

    // Reg - soc_ifc_reg::fuse_manuf_dbg_unlock_token
    class soc_ifc_reg__fuse_manuf_dbg_unlock_token extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__fuse_manuf_dbg_unlock_token_bit_cg token_bit_cg[32];
        soc_ifc_reg__fuse_manuf_dbg_unlock_token_fld_cg fld_cg;
        rand uvm_reg_field token;

        function new(string name = "soc_ifc_reg__fuse_manuf_dbg_unlock_token");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.token = new("token");
            this.token.configure(this, 32, 0, "RW", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(token_bit_cg[bt]) token_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__fuse_manuf_dbg_unlock_token

    // Reg - soc_ifc_reg::SS_CALIPTRA_BASE_ADDR_L
    class soc_ifc_reg__SS_CALIPTRA_BASE_ADDR_L extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__SS_CALIPTRA_BASE_ADDR_L_bit_cg addr_l_bit_cg[32];
        soc_ifc_reg__SS_CALIPTRA_BASE_ADDR_L_fld_cg fld_cg;
        rand uvm_reg_field addr_l;

        function new(string name = "soc_ifc_reg__SS_CALIPTRA_BASE_ADDR_L");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.addr_l = new("addr_l");
            this.addr_l.configure(this, 32, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(addr_l_bit_cg[bt]) addr_l_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__SS_CALIPTRA_BASE_ADDR_L

    // Reg - soc_ifc_reg::SS_CALIPTRA_BASE_ADDR_H
    class soc_ifc_reg__SS_CALIPTRA_BASE_ADDR_H extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__SS_CALIPTRA_BASE_ADDR_H_bit_cg addr_h_bit_cg[32];
        soc_ifc_reg__SS_CALIPTRA_BASE_ADDR_H_fld_cg fld_cg;
        rand uvm_reg_field addr_h;

        function new(string name = "soc_ifc_reg__SS_CALIPTRA_BASE_ADDR_H");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.addr_h = new("addr_h");
            this.addr_h.configure(this, 32, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(addr_h_bit_cg[bt]) addr_h_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__SS_CALIPTRA_BASE_ADDR_H

    // Reg - soc_ifc_reg::SS_MCI_BASE_ADDR_L
    class soc_ifc_reg__SS_MCI_BASE_ADDR_L extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__SS_MCI_BASE_ADDR_L_bit_cg addr_l_bit_cg[32];
        soc_ifc_reg__SS_MCI_BASE_ADDR_L_fld_cg fld_cg;
        rand uvm_reg_field addr_l;

        function new(string name = "soc_ifc_reg__SS_MCI_BASE_ADDR_L");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.addr_l = new("addr_l");
            this.addr_l.configure(this, 32, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(addr_l_bit_cg[bt]) addr_l_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__SS_MCI_BASE_ADDR_L

    // Reg - soc_ifc_reg::SS_MCI_BASE_ADDR_H
    class soc_ifc_reg__SS_MCI_BASE_ADDR_H extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__SS_MCI_BASE_ADDR_H_bit_cg addr_h_bit_cg[32];
        soc_ifc_reg__SS_MCI_BASE_ADDR_H_fld_cg fld_cg;
        rand uvm_reg_field addr_h;

        function new(string name = "soc_ifc_reg__SS_MCI_BASE_ADDR_H");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.addr_h = new("addr_h");
            this.addr_h.configure(this, 32, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(addr_h_bit_cg[bt]) addr_h_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__SS_MCI_BASE_ADDR_H

    // Reg - soc_ifc_reg::SS_RECOVERY_IFC_BASE_ADDR_L
    class soc_ifc_reg__SS_RECOVERY_IFC_BASE_ADDR_L extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__SS_RECOVERY_IFC_BASE_ADDR_L_bit_cg addr_l_bit_cg[32];
        soc_ifc_reg__SS_RECOVERY_IFC_BASE_ADDR_L_fld_cg fld_cg;
        rand uvm_reg_field addr_l;

        function new(string name = "soc_ifc_reg__SS_RECOVERY_IFC_BASE_ADDR_L");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.addr_l = new("addr_l");
            this.addr_l.configure(this, 32, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(addr_l_bit_cg[bt]) addr_l_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__SS_RECOVERY_IFC_BASE_ADDR_L

    // Reg - soc_ifc_reg::SS_RECOVERY_IFC_BASE_ADDR_H
    class soc_ifc_reg__SS_RECOVERY_IFC_BASE_ADDR_H extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__SS_RECOVERY_IFC_BASE_ADDR_H_bit_cg addr_h_bit_cg[32];
        soc_ifc_reg__SS_RECOVERY_IFC_BASE_ADDR_H_fld_cg fld_cg;
        rand uvm_reg_field addr_h;

        function new(string name = "soc_ifc_reg__SS_RECOVERY_IFC_BASE_ADDR_H");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.addr_h = new("addr_h");
            this.addr_h.configure(this, 32, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(addr_h_bit_cg[bt]) addr_h_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__SS_RECOVERY_IFC_BASE_ADDR_H

    // Reg - soc_ifc_reg::SS_OTP_FC_BASE_ADDR_L
    class soc_ifc_reg__SS_OTP_FC_BASE_ADDR_L extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__SS_OTP_FC_BASE_ADDR_L_bit_cg addr_l_bit_cg[32];
        soc_ifc_reg__SS_OTP_FC_BASE_ADDR_L_fld_cg fld_cg;
        rand uvm_reg_field addr_l;

        function new(string name = "soc_ifc_reg__SS_OTP_FC_BASE_ADDR_L");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.addr_l = new("addr_l");
            this.addr_l.configure(this, 32, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(addr_l_bit_cg[bt]) addr_l_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__SS_OTP_FC_BASE_ADDR_L

    // Reg - soc_ifc_reg::SS_OTP_FC_BASE_ADDR_H
    class soc_ifc_reg__SS_OTP_FC_BASE_ADDR_H extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__SS_OTP_FC_BASE_ADDR_H_bit_cg addr_h_bit_cg[32];
        soc_ifc_reg__SS_OTP_FC_BASE_ADDR_H_fld_cg fld_cg;
        rand uvm_reg_field addr_h;

        function new(string name = "soc_ifc_reg__SS_OTP_FC_BASE_ADDR_H");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.addr_h = new("addr_h");
            this.addr_h.configure(this, 32, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(addr_h_bit_cg[bt]) addr_h_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__SS_OTP_FC_BASE_ADDR_H

    // Reg - soc_ifc_reg::SS_UDS_SEED_BASE_ADDR_L
    class soc_ifc_reg__SS_UDS_SEED_BASE_ADDR_L extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__SS_UDS_SEED_BASE_ADDR_L_bit_cg addr_l_bit_cg[32];
        soc_ifc_reg__SS_UDS_SEED_BASE_ADDR_L_fld_cg fld_cg;
        rand uvm_reg_field addr_l;

        function new(string name = "soc_ifc_reg__SS_UDS_SEED_BASE_ADDR_L");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.addr_l = new("addr_l");
            this.addr_l.configure(this, 32, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(addr_l_bit_cg[bt]) addr_l_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__SS_UDS_SEED_BASE_ADDR_L

    // Reg - soc_ifc_reg::SS_UDS_SEED_BASE_ADDR_H
    class soc_ifc_reg__SS_UDS_SEED_BASE_ADDR_H extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__SS_UDS_SEED_BASE_ADDR_H_bit_cg addr_h_bit_cg[32];
        soc_ifc_reg__SS_UDS_SEED_BASE_ADDR_H_fld_cg fld_cg;
        rand uvm_reg_field addr_h;

        function new(string name = "soc_ifc_reg__SS_UDS_SEED_BASE_ADDR_H");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.addr_h = new("addr_h");
            this.addr_h.configure(this, 32, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(addr_h_bit_cg[bt]) addr_h_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__SS_UDS_SEED_BASE_ADDR_H

    // Reg - soc_ifc_reg::SS_PROD_DEBUG_UNLOCK_AUTH_PK_HASH_REG_BANK_OFFSET
    class soc_ifc_reg__SS_PROD_DEBUG_UNLOCK_AUTH_PK_HASH_REG_BANK_OFFSET extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__SS_PROD_DEBUG_UNLOCK_AUTH_PK_HASH_REG_BANK_OFFSET_bit_cg offset_bit_cg[32];
        soc_ifc_reg__SS_PROD_DEBUG_UNLOCK_AUTH_PK_HASH_REG_BANK_OFFSET_fld_cg fld_cg;
        rand uvm_reg_field offset;

        function new(string name = "soc_ifc_reg__SS_PROD_DEBUG_UNLOCK_AUTH_PK_HASH_REG_BANK_OFFSET");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.offset = new("offset");
            this.offset.configure(this, 32, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(offset_bit_cg[bt]) offset_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__SS_PROD_DEBUG_UNLOCK_AUTH_PK_HASH_REG_BANK_OFFSET

    // Reg - soc_ifc_reg::SS_NUM_OF_PROD_DEBUG_UNLOCK_AUTH_PK_HASHES
    class soc_ifc_reg__SS_NUM_OF_PROD_DEBUG_UNLOCK_AUTH_PK_HASHES extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__SS_NUM_OF_PROD_DEBUG_UNLOCK_AUTH_PK_HASHES_bit_cg num_bit_cg[32];
        soc_ifc_reg__SS_NUM_OF_PROD_DEBUG_UNLOCK_AUTH_PK_HASHES_fld_cg fld_cg;
        rand uvm_reg_field num;

        function new(string name = "soc_ifc_reg__SS_NUM_OF_PROD_DEBUG_UNLOCK_AUTH_PK_HASHES");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.num = new("num");
            this.num.configure(this, 32, 0, "RW", 1, 'h8, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(num_bit_cg[bt]) num_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__SS_NUM_OF_PROD_DEBUG_UNLOCK_AUTH_PK_HASHES

    // Reg - soc_ifc_reg::SS_DEBUG_INTENT
    class soc_ifc_reg__SS_DEBUG_INTENT extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__SS_DEBUG_INTENT_bit_cg debug_intent_bit_cg[1];
        soc_ifc_reg__SS_DEBUG_INTENT_fld_cg fld_cg;
        rand uvm_reg_field debug_intent;

        function new(string name = "soc_ifc_reg__SS_DEBUG_INTENT");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.debug_intent = new("debug_intent");
            this.debug_intent.configure(this, 1, 0, "RO", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(debug_intent_bit_cg[bt]) debug_intent_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__SS_DEBUG_INTENT

    // Reg - soc_ifc_reg::SS_STRAP_GENERIC
    class soc_ifc_reg__SS_STRAP_GENERIC extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__SS_STRAP_GENERIC_bit_cg data_bit_cg[32];
        soc_ifc_reg__SS_STRAP_GENERIC_fld_cg fld_cg;
        rand uvm_reg_field data;

        function new(string name = "soc_ifc_reg__SS_STRAP_GENERIC");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.data = new("data");
            this.data.configure(this, 32, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(data_bit_cg[bt]) data_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__SS_STRAP_GENERIC

    // Reg - soc_ifc_reg::SS_DBG_MANUF_SERVICE_REG_REQ
    class soc_ifc_reg__SS_DBG_MANUF_SERVICE_REG_REQ extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__SS_DBG_MANUF_SERVICE_REG_REQ_bit_cg MANUF_DBG_UNLOCK_REQ_bit_cg[1];
        soc_ifc_reg__SS_DBG_MANUF_SERVICE_REG_REQ_bit_cg PROD_DBG_UNLOCK_REQ_bit_cg[1];
        soc_ifc_reg__SS_DBG_MANUF_SERVICE_REG_REQ_bit_cg UDS_PROGRAM_REQ_bit_cg[1];
        soc_ifc_reg__SS_DBG_MANUF_SERVICE_REG_REQ_bit_cg RSVD_bit_cg[29];
        soc_ifc_reg__SS_DBG_MANUF_SERVICE_REG_REQ_fld_cg fld_cg;
        rand uvm_reg_field MANUF_DBG_UNLOCK_REQ;
        rand uvm_reg_field PROD_DBG_UNLOCK_REQ;
        rand uvm_reg_field UDS_PROGRAM_REQ;
        rand uvm_reg_field RSVD;

        function new(string name = "soc_ifc_reg__SS_DBG_MANUF_SERVICE_REG_REQ");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.MANUF_DBG_UNLOCK_REQ = new("MANUF_DBG_UNLOCK_REQ");
            this.MANUF_DBG_UNLOCK_REQ.configure(this, 1, 0, "RW", 1, 'h0, 1, 1, 0);
            this.PROD_DBG_UNLOCK_REQ = new("PROD_DBG_UNLOCK_REQ");
            this.PROD_DBG_UNLOCK_REQ.configure(this, 1, 1, "RW", 1, 'h0, 1, 1, 0);
            this.UDS_PROGRAM_REQ = new("UDS_PROGRAM_REQ");
            this.UDS_PROGRAM_REQ.configure(this, 1, 2, "RW", 1, 'h0, 1, 1, 0);
            this.RSVD = new("RSVD");
            this.RSVD.configure(this, 29, 3, "RO", 1, 'h0, 0, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(MANUF_DBG_UNLOCK_REQ_bit_cg[bt]) MANUF_DBG_UNLOCK_REQ_bit_cg[bt] = new();
                foreach(PROD_DBG_UNLOCK_REQ_bit_cg[bt]) PROD_DBG_UNLOCK_REQ_bit_cg[bt] = new();
                foreach(UDS_PROGRAM_REQ_bit_cg[bt]) UDS_PROGRAM_REQ_bit_cg[bt] = new();
                foreach(RSVD_bit_cg[bt]) RSVD_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__SS_DBG_MANUF_SERVICE_REG_REQ

    // Reg - soc_ifc_reg::SS_DBG_MANUF_SERVICE_REG_RSP
    class soc_ifc_reg__SS_DBG_MANUF_SERVICE_REG_RSP extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__SS_DBG_MANUF_SERVICE_REG_RSP_bit_cg MANUF_DBG_UNLOCK_SUCCESS_bit_cg[1];
        soc_ifc_reg__SS_DBG_MANUF_SERVICE_REG_RSP_bit_cg MANUF_DBG_UNLOCK_FAIL_bit_cg[1];
        soc_ifc_reg__SS_DBG_MANUF_SERVICE_REG_RSP_bit_cg MANUF_DBG_UNLOCK_IN_PROGRESS_bit_cg[1];
        soc_ifc_reg__SS_DBG_MANUF_SERVICE_REG_RSP_bit_cg PROD_DBG_UNLOCK_SUCCESS_bit_cg[1];
        soc_ifc_reg__SS_DBG_MANUF_SERVICE_REG_RSP_bit_cg PROD_DBG_UNLOCK_FAIL_bit_cg[1];
        soc_ifc_reg__SS_DBG_MANUF_SERVICE_REG_RSP_bit_cg PROD_DBG_UNLOCK_IN_PROGRESS_bit_cg[1];
        soc_ifc_reg__SS_DBG_MANUF_SERVICE_REG_RSP_bit_cg UDS_PROGRAM_SUCCESS_bit_cg[1];
        soc_ifc_reg__SS_DBG_MANUF_SERVICE_REG_RSP_bit_cg UDS_PROGRAM_FAIL_bit_cg[1];
        soc_ifc_reg__SS_DBG_MANUF_SERVICE_REG_RSP_bit_cg UDS_PROGRAM_IN_PROGRESS_bit_cg[1];
        soc_ifc_reg__SS_DBG_MANUF_SERVICE_REG_RSP_bit_cg RSVD_bit_cg[23];
        soc_ifc_reg__SS_DBG_MANUF_SERVICE_REG_RSP_fld_cg fld_cg;
        rand uvm_reg_field MANUF_DBG_UNLOCK_SUCCESS;
        rand uvm_reg_field MANUF_DBG_UNLOCK_FAIL;
        rand uvm_reg_field MANUF_DBG_UNLOCK_IN_PROGRESS;
        rand uvm_reg_field PROD_DBG_UNLOCK_SUCCESS;
        rand uvm_reg_field PROD_DBG_UNLOCK_FAIL;
        rand uvm_reg_field PROD_DBG_UNLOCK_IN_PROGRESS;
        rand uvm_reg_field UDS_PROGRAM_SUCCESS;
        rand uvm_reg_field UDS_PROGRAM_FAIL;
        rand uvm_reg_field UDS_PROGRAM_IN_PROGRESS;
        rand uvm_reg_field RSVD;

        function new(string name = "soc_ifc_reg__SS_DBG_MANUF_SERVICE_REG_RSP");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.MANUF_DBG_UNLOCK_SUCCESS = new("MANUF_DBG_UNLOCK_SUCCESS");
            this.MANUF_DBG_UNLOCK_SUCCESS.configure(this, 1, 0, "RW", 1, 'h0, 1, 1, 0);
            this.MANUF_DBG_UNLOCK_FAIL = new("MANUF_DBG_UNLOCK_FAIL");
            this.MANUF_DBG_UNLOCK_FAIL.configure(this, 1, 1, "RW", 1, 'h0, 1, 1, 0);
            this.MANUF_DBG_UNLOCK_IN_PROGRESS = new("MANUF_DBG_UNLOCK_IN_PROGRESS");
            this.MANUF_DBG_UNLOCK_IN_PROGRESS.configure(this, 1, 2, "RW", 1, 'h0, 1, 1, 0);
            this.PROD_DBG_UNLOCK_SUCCESS = new("PROD_DBG_UNLOCK_SUCCESS");
            this.PROD_DBG_UNLOCK_SUCCESS.configure(this, 1, 3, "RW", 1, 'h0, 1, 1, 0);
            this.PROD_DBG_UNLOCK_FAIL = new("PROD_DBG_UNLOCK_FAIL");
            this.PROD_DBG_UNLOCK_FAIL.configure(this, 1, 4, "RW", 1, 'h0, 1, 1, 0);
            this.PROD_DBG_UNLOCK_IN_PROGRESS = new("PROD_DBG_UNLOCK_IN_PROGRESS");
            this.PROD_DBG_UNLOCK_IN_PROGRESS.configure(this, 1, 5, "RW", 1, 'h0, 1, 1, 0);
            this.UDS_PROGRAM_SUCCESS = new("UDS_PROGRAM_SUCCESS");
            this.UDS_PROGRAM_SUCCESS.configure(this, 1, 6, "RW", 1, 'h0, 1, 1, 0);
            this.UDS_PROGRAM_FAIL = new("UDS_PROGRAM_FAIL");
            this.UDS_PROGRAM_FAIL.configure(this, 1, 7, "RW", 1, 'h0, 1, 1, 0);
            this.UDS_PROGRAM_IN_PROGRESS = new("UDS_PROGRAM_IN_PROGRESS");
            this.UDS_PROGRAM_IN_PROGRESS.configure(this, 1, 8, "RW", 1, 'h0, 1, 1, 0);
            this.RSVD = new("RSVD");
            this.RSVD.configure(this, 23, 9, "RO", 1, 'h0, 0, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(MANUF_DBG_UNLOCK_SUCCESS_bit_cg[bt]) MANUF_DBG_UNLOCK_SUCCESS_bit_cg[bt] = new();
                foreach(MANUF_DBG_UNLOCK_FAIL_bit_cg[bt]) MANUF_DBG_UNLOCK_FAIL_bit_cg[bt] = new();
                foreach(MANUF_DBG_UNLOCK_IN_PROGRESS_bit_cg[bt]) MANUF_DBG_UNLOCK_IN_PROGRESS_bit_cg[bt] = new();
                foreach(PROD_DBG_UNLOCK_SUCCESS_bit_cg[bt]) PROD_DBG_UNLOCK_SUCCESS_bit_cg[bt] = new();
                foreach(PROD_DBG_UNLOCK_FAIL_bit_cg[bt]) PROD_DBG_UNLOCK_FAIL_bit_cg[bt] = new();
                foreach(PROD_DBG_UNLOCK_IN_PROGRESS_bit_cg[bt]) PROD_DBG_UNLOCK_IN_PROGRESS_bit_cg[bt] = new();
                foreach(UDS_PROGRAM_SUCCESS_bit_cg[bt]) UDS_PROGRAM_SUCCESS_bit_cg[bt] = new();
                foreach(UDS_PROGRAM_FAIL_bit_cg[bt]) UDS_PROGRAM_FAIL_bit_cg[bt] = new();
                foreach(UDS_PROGRAM_IN_PROGRESS_bit_cg[bt]) UDS_PROGRAM_IN_PROGRESS_bit_cg[bt] = new();
                foreach(RSVD_bit_cg[bt]) RSVD_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__SS_DBG_MANUF_SERVICE_REG_RSP

    // Reg - soc_ifc_reg::SS_SOC_DBG_UNLOCK_LEVEL
    class soc_ifc_reg__SS_SOC_DBG_UNLOCK_LEVEL extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__SS_SOC_DBG_UNLOCK_LEVEL_bit_cg LEVEL_bit_cg[32];
        soc_ifc_reg__SS_SOC_DBG_UNLOCK_LEVEL_fld_cg fld_cg;
        rand uvm_reg_field LEVEL;

        function new(string name = "soc_ifc_reg__SS_SOC_DBG_UNLOCK_LEVEL");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.LEVEL = new("LEVEL");
            this.LEVEL.configure(this, 32, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(LEVEL_bit_cg[bt]) LEVEL_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__SS_SOC_DBG_UNLOCK_LEVEL

    // Reg - soc_ifc_reg::SS_GENERIC_FW_EXEC_CTRL
    class soc_ifc_reg__SS_GENERIC_FW_EXEC_CTRL extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__SS_GENERIC_FW_EXEC_CTRL_bit_cg go_bit_cg[32];
        soc_ifc_reg__SS_GENERIC_FW_EXEC_CTRL_fld_cg fld_cg;
        rand uvm_reg_field go;

        function new(string name = "soc_ifc_reg__SS_GENERIC_FW_EXEC_CTRL");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.go = new("go");
            this.go.configure(this, 32, 0, "RW", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(go_bit_cg[bt]) go_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__SS_GENERIC_FW_EXEC_CTRL

    // Reg - soc_ifc_reg::internal_obf_key
    class soc_ifc_reg__internal_obf_key extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__internal_obf_key_bit_cg key_bit_cg[32];
        soc_ifc_reg__internal_obf_key_fld_cg fld_cg;
        rand uvm_reg_field key;

        function new(string name = "soc_ifc_reg__internal_obf_key");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.key = new("key");
            this.key.configure(this, 32, 0, "WO", 1, 'h0, 0, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(key_bit_cg[bt]) key_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__internal_obf_key

    // Reg - soc_ifc_reg::internal_iccm_lock
    class soc_ifc_reg__internal_iccm_lock extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__internal_iccm_lock_bit_cg lock_bit_cg[1];
        soc_ifc_reg__internal_iccm_lock_fld_cg fld_cg;
        rand uvm_reg_field lock;

        function new(string name = "soc_ifc_reg__internal_iccm_lock");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.lock = new("lock");
            this.lock.configure(this, 1, 0, "W1S", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(lock_bit_cg[bt]) lock_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__internal_iccm_lock

    // Reg - soc_ifc_reg::internal_fw_update_reset
    class soc_ifc_reg__internal_fw_update_reset extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__internal_fw_update_reset_bit_cg core_rst_bit_cg[1];
        soc_ifc_reg__internal_fw_update_reset_fld_cg fld_cg;
        rand uvm_reg_field core_rst;

        function new(string name = "soc_ifc_reg__internal_fw_update_reset");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.core_rst = new("core_rst");
            this.core_rst.configure(this, 1, 0, "RW", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(core_rst_bit_cg[bt]) core_rst_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__internal_fw_update_reset

    // Reg - soc_ifc_reg::internal_fw_update_reset_wait_cycles
    class soc_ifc_reg__internal_fw_update_reset_wait_cycles extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__internal_fw_update_reset_wait_cycles_bit_cg wait_cycles_bit_cg[8];
        soc_ifc_reg__internal_fw_update_reset_wait_cycles_fld_cg fld_cg;
        rand uvm_reg_field wait_cycles;

        function new(string name = "soc_ifc_reg__internal_fw_update_reset_wait_cycles");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.wait_cycles = new("wait_cycles");
            this.wait_cycles.configure(this, 8, 0, "RW", 0, 'h5, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(wait_cycles_bit_cg[bt]) wait_cycles_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__internal_fw_update_reset_wait_cycles

    // Reg - soc_ifc_reg::internal_nmi_vector
    class soc_ifc_reg__internal_nmi_vector extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__internal_nmi_vector_bit_cg vec_bit_cg[32];
        soc_ifc_reg__internal_nmi_vector_fld_cg fld_cg;
        rand uvm_reg_field vec;

        function new(string name = "soc_ifc_reg__internal_nmi_vector");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.vec = new("vec");
            this.vec.configure(this, 32, 0, "RW", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(vec_bit_cg[bt]) vec_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__internal_nmi_vector

    // Reg - soc_ifc_reg::internal_hw_error_fatal_mask
    class soc_ifc_reg__internal_hw_error_fatal_mask extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__internal_hw_error_fatal_mask_bit_cg mask_iccm_ecc_unc_bit_cg[1];
        soc_ifc_reg__internal_hw_error_fatal_mask_bit_cg mask_dccm_ecc_unc_bit_cg[1];
        soc_ifc_reg__internal_hw_error_fatal_mask_bit_cg mask_nmi_pin_bit_cg[1];
        soc_ifc_reg__internal_hw_error_fatal_mask_bit_cg mask_crypto_err_bit_cg[1];
        soc_ifc_reg__internal_hw_error_fatal_mask_fld_cg fld_cg;
        rand uvm_reg_field mask_iccm_ecc_unc;
        rand uvm_reg_field mask_dccm_ecc_unc;
        rand uvm_reg_field mask_nmi_pin;
        rand uvm_reg_field mask_crypto_err;

        function new(string name = "soc_ifc_reg__internal_hw_error_fatal_mask");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.mask_iccm_ecc_unc = new("mask_iccm_ecc_unc");
            this.mask_iccm_ecc_unc.configure(this, 1, 0, "RW", 0, 'h0, 1, 1, 0);
            this.mask_dccm_ecc_unc = new("mask_dccm_ecc_unc");
            this.mask_dccm_ecc_unc.configure(this, 1, 1, "RW", 0, 'h0, 1, 1, 0);
            this.mask_nmi_pin = new("mask_nmi_pin");
            this.mask_nmi_pin.configure(this, 1, 2, "RW", 0, 'h0, 1, 1, 0);
            this.mask_crypto_err = new("mask_crypto_err");
            this.mask_crypto_err.configure(this, 1, 3, "RO", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(mask_iccm_ecc_unc_bit_cg[bt]) mask_iccm_ecc_unc_bit_cg[bt] = new();
                foreach(mask_dccm_ecc_unc_bit_cg[bt]) mask_dccm_ecc_unc_bit_cg[bt] = new();
                foreach(mask_nmi_pin_bit_cg[bt]) mask_nmi_pin_bit_cg[bt] = new();
                foreach(mask_crypto_err_bit_cg[bt]) mask_crypto_err_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__internal_hw_error_fatal_mask

    // Reg - soc_ifc_reg::internal_hw_error_non_fatal_mask
    class soc_ifc_reg__internal_hw_error_non_fatal_mask extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__internal_hw_error_non_fatal_mask_bit_cg mask_mbox_prot_no_lock_bit_cg[1];
        soc_ifc_reg__internal_hw_error_non_fatal_mask_bit_cg mask_mbox_prot_ooo_bit_cg[1];
        soc_ifc_reg__internal_hw_error_non_fatal_mask_bit_cg mask_mbox_ecc_unc_bit_cg[1];
        soc_ifc_reg__internal_hw_error_non_fatal_mask_fld_cg fld_cg;
        rand uvm_reg_field mask_mbox_prot_no_lock;
        rand uvm_reg_field mask_mbox_prot_ooo;
        rand uvm_reg_field mask_mbox_ecc_unc;

        function new(string name = "soc_ifc_reg__internal_hw_error_non_fatal_mask");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.mask_mbox_prot_no_lock = new("mask_mbox_prot_no_lock");
            this.mask_mbox_prot_no_lock.configure(this, 1, 0, "RW", 0, 'h0, 1, 1, 0);
            this.mask_mbox_prot_ooo = new("mask_mbox_prot_ooo");
            this.mask_mbox_prot_ooo.configure(this, 1, 1, "RW", 0, 'h0, 1, 1, 0);
            this.mask_mbox_ecc_unc = new("mask_mbox_ecc_unc");
            this.mask_mbox_ecc_unc.configure(this, 1, 2, "RW", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(mask_mbox_prot_no_lock_bit_cg[bt]) mask_mbox_prot_no_lock_bit_cg[bt] = new();
                foreach(mask_mbox_prot_ooo_bit_cg[bt]) mask_mbox_prot_ooo_bit_cg[bt] = new();
                foreach(mask_mbox_ecc_unc_bit_cg[bt]) mask_mbox_ecc_unc_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__internal_hw_error_non_fatal_mask

    // Reg - soc_ifc_reg::internal_fw_error_fatal_mask
    class soc_ifc_reg__internal_fw_error_fatal_mask extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__internal_fw_error_fatal_mask_bit_cg mask_bit_cg[32];
        soc_ifc_reg__internal_fw_error_fatal_mask_fld_cg fld_cg;
        rand uvm_reg_field mask;

        function new(string name = "soc_ifc_reg__internal_fw_error_fatal_mask");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.mask = new("mask");
            this.mask.configure(this, 32, 0, "RW", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(mask_bit_cg[bt]) mask_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__internal_fw_error_fatal_mask

    // Reg - soc_ifc_reg::internal_fw_error_non_fatal_mask
    class soc_ifc_reg__internal_fw_error_non_fatal_mask extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__internal_fw_error_non_fatal_mask_bit_cg mask_bit_cg[32];
        soc_ifc_reg__internal_fw_error_non_fatal_mask_fld_cg fld_cg;
        rand uvm_reg_field mask;

        function new(string name = "soc_ifc_reg__internal_fw_error_non_fatal_mask");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.mask = new("mask");
            this.mask.configure(this, 32, 0, "RW", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(mask_bit_cg[bt]) mask_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__internal_fw_error_non_fatal_mask

    // Reg - soc_ifc_reg::internal_rv_mtime_l
    class soc_ifc_reg__internal_rv_mtime_l extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__internal_rv_mtime_l_bit_cg count_l_bit_cg[32];
        soc_ifc_reg__internal_rv_mtime_l_fld_cg fld_cg;
        rand uvm_reg_field count_l;

        function new(string name = "soc_ifc_reg__internal_rv_mtime_l");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.count_l = new("count_l");
            this.count_l.configure(this, 32, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(count_l_bit_cg[bt]) count_l_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__internal_rv_mtime_l

    // Reg - soc_ifc_reg::internal_rv_mtime_h
    class soc_ifc_reg__internal_rv_mtime_h extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__internal_rv_mtime_h_bit_cg count_h_bit_cg[32];
        soc_ifc_reg__internal_rv_mtime_h_fld_cg fld_cg;
        rand uvm_reg_field count_h;

        function new(string name = "soc_ifc_reg__internal_rv_mtime_h");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.count_h = new("count_h");
            this.count_h.configure(this, 32, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(count_h_bit_cg[bt]) count_h_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__internal_rv_mtime_h

    // Reg - soc_ifc_reg::internal_rv_mtimecmp_l
    class soc_ifc_reg__internal_rv_mtimecmp_l extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__internal_rv_mtimecmp_l_bit_cg compare_l_bit_cg[32];
        soc_ifc_reg__internal_rv_mtimecmp_l_fld_cg fld_cg;
        rand uvm_reg_field compare_l;

        function new(string name = "soc_ifc_reg__internal_rv_mtimecmp_l");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.compare_l = new("compare_l");
            this.compare_l.configure(this, 32, 0, "RW", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(compare_l_bit_cg[bt]) compare_l_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__internal_rv_mtimecmp_l

    // Reg - soc_ifc_reg::internal_rv_mtimecmp_h
    class soc_ifc_reg__internal_rv_mtimecmp_h extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__internal_rv_mtimecmp_h_bit_cg compare_h_bit_cg[32];
        soc_ifc_reg__internal_rv_mtimecmp_h_fld_cg fld_cg;
        rand uvm_reg_field compare_h;

        function new(string name = "soc_ifc_reg__internal_rv_mtimecmp_h");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.compare_h = new("compare_h");
            this.compare_h.configure(this, 32, 0, "RW", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(compare_h_bit_cg[bt]) compare_h_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__internal_rv_mtimecmp_h

    // Reg - soc_ifc_reg::intr_block_t::global_intr_en_t
    class soc_ifc_reg__intr_block_t__global_intr_en_t extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__intr_block_t__global_intr_en_t_bit_cg error_en_bit_cg[1];
        soc_ifc_reg__intr_block_t__global_intr_en_t_bit_cg notif_en_bit_cg[1];
        soc_ifc_reg__intr_block_t__global_intr_en_t_fld_cg fld_cg;
        rand uvm_reg_field error_en;
        rand uvm_reg_field notif_en;

        function new(string name = "soc_ifc_reg__intr_block_t__global_intr_en_t");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.error_en = new("error_en");
            this.error_en.configure(this, 1, 0, "RW", 0, 'h0, 1, 1, 0);
            this.notif_en = new("notif_en");
            this.notif_en.configure(this, 1, 1, "RW", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(error_en_bit_cg[bt]) error_en_bit_cg[bt] = new();
                foreach(notif_en_bit_cg[bt]) notif_en_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__intr_block_t__global_intr_en_t

    // Reg - soc_ifc_reg::intr_block_t::error_intr_en_t
    class soc_ifc_reg__intr_block_t__error_intr_en_t extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__intr_block_t__error_intr_en_t_bit_cg error_internal_en_bit_cg[1];
        soc_ifc_reg__intr_block_t__error_intr_en_t_bit_cg error_inv_dev_en_bit_cg[1];
        soc_ifc_reg__intr_block_t__error_intr_en_t_bit_cg error_cmd_fail_en_bit_cg[1];
        soc_ifc_reg__intr_block_t__error_intr_en_t_bit_cg error_bad_fuse_en_bit_cg[1];
        soc_ifc_reg__intr_block_t__error_intr_en_t_bit_cg error_iccm_blocked_en_bit_cg[1];
        soc_ifc_reg__intr_block_t__error_intr_en_t_bit_cg error_mbox_ecc_unc_en_bit_cg[1];
        soc_ifc_reg__intr_block_t__error_intr_en_t_bit_cg error_wdt_timer1_timeout_en_bit_cg[1];
        soc_ifc_reg__intr_block_t__error_intr_en_t_bit_cg error_wdt_timer2_timeout_en_bit_cg[1];
        soc_ifc_reg__intr_block_t__error_intr_en_t_fld_cg fld_cg;
        rand uvm_reg_field error_internal_en;
        rand uvm_reg_field error_inv_dev_en;
        rand uvm_reg_field error_cmd_fail_en;
        rand uvm_reg_field error_bad_fuse_en;
        rand uvm_reg_field error_iccm_blocked_en;
        rand uvm_reg_field error_mbox_ecc_unc_en;
        rand uvm_reg_field error_wdt_timer1_timeout_en;
        rand uvm_reg_field error_wdt_timer2_timeout_en;

        function new(string name = "soc_ifc_reg__intr_block_t__error_intr_en_t");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.error_internal_en = new("error_internal_en");
            this.error_internal_en.configure(this, 1, 0, "RW", 0, 'h0, 1, 1, 0);
            this.error_inv_dev_en = new("error_inv_dev_en");
            this.error_inv_dev_en.configure(this, 1, 1, "RW", 0, 'h0, 1, 1, 0);
            this.error_cmd_fail_en = new("error_cmd_fail_en");
            this.error_cmd_fail_en.configure(this, 1, 2, "RW", 0, 'h0, 1, 1, 0);
            this.error_bad_fuse_en = new("error_bad_fuse_en");
            this.error_bad_fuse_en.configure(this, 1, 3, "RW", 0, 'h0, 1, 1, 0);
            this.error_iccm_blocked_en = new("error_iccm_blocked_en");
            this.error_iccm_blocked_en.configure(this, 1, 4, "RW", 0, 'h0, 1, 1, 0);
            this.error_mbox_ecc_unc_en = new("error_mbox_ecc_unc_en");
            this.error_mbox_ecc_unc_en.configure(this, 1, 5, "RW", 0, 'h0, 1, 1, 0);
            this.error_wdt_timer1_timeout_en = new("error_wdt_timer1_timeout_en");
            this.error_wdt_timer1_timeout_en.configure(this, 1, 6, "RW", 0, 'h0, 1, 1, 0);
            this.error_wdt_timer2_timeout_en = new("error_wdt_timer2_timeout_en");
            this.error_wdt_timer2_timeout_en.configure(this, 1, 7, "RW", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(error_internal_en_bit_cg[bt]) error_internal_en_bit_cg[bt] = new();
                foreach(error_inv_dev_en_bit_cg[bt]) error_inv_dev_en_bit_cg[bt] = new();
                foreach(error_cmd_fail_en_bit_cg[bt]) error_cmd_fail_en_bit_cg[bt] = new();
                foreach(error_bad_fuse_en_bit_cg[bt]) error_bad_fuse_en_bit_cg[bt] = new();
                foreach(error_iccm_blocked_en_bit_cg[bt]) error_iccm_blocked_en_bit_cg[bt] = new();
                foreach(error_mbox_ecc_unc_en_bit_cg[bt]) error_mbox_ecc_unc_en_bit_cg[bt] = new();
                foreach(error_wdt_timer1_timeout_en_bit_cg[bt]) error_wdt_timer1_timeout_en_bit_cg[bt] = new();
                foreach(error_wdt_timer2_timeout_en_bit_cg[bt]) error_wdt_timer2_timeout_en_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__intr_block_t__error_intr_en_t

    // Reg - soc_ifc_reg::intr_block_t::notif_intr_en_t
    class soc_ifc_reg__intr_block_t__notif_intr_en_t extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__intr_block_t__notif_intr_en_t_bit_cg notif_cmd_avail_en_bit_cg[1];
        soc_ifc_reg__intr_block_t__notif_intr_en_t_bit_cg notif_mbox_ecc_cor_en_bit_cg[1];
        soc_ifc_reg__intr_block_t__notif_intr_en_t_bit_cg notif_debug_locked_en_bit_cg[1];
        soc_ifc_reg__intr_block_t__notif_intr_en_t_bit_cg notif_scan_mode_en_bit_cg[1];
        soc_ifc_reg__intr_block_t__notif_intr_en_t_bit_cg notif_soc_req_lock_en_bit_cg[1];
        soc_ifc_reg__intr_block_t__notif_intr_en_t_bit_cg notif_gen_in_toggle_en_bit_cg[1];
        soc_ifc_reg__intr_block_t__notif_intr_en_t_fld_cg fld_cg;
        rand uvm_reg_field notif_cmd_avail_en;
        rand uvm_reg_field notif_mbox_ecc_cor_en;
        rand uvm_reg_field notif_debug_locked_en;
        rand uvm_reg_field notif_scan_mode_en;
        rand uvm_reg_field notif_soc_req_lock_en;
        rand uvm_reg_field notif_gen_in_toggle_en;

        function new(string name = "soc_ifc_reg__intr_block_t__notif_intr_en_t");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.notif_cmd_avail_en = new("notif_cmd_avail_en");
            this.notif_cmd_avail_en.configure(this, 1, 0, "RW", 0, 'h0, 1, 1, 0);
            this.notif_mbox_ecc_cor_en = new("notif_mbox_ecc_cor_en");
            this.notif_mbox_ecc_cor_en.configure(this, 1, 1, "RW", 0, 'h0, 1, 1, 0);
            this.notif_debug_locked_en = new("notif_debug_locked_en");
            this.notif_debug_locked_en.configure(this, 1, 2, "RW", 0, 'h0, 1, 1, 0);
            this.notif_scan_mode_en = new("notif_scan_mode_en");
            this.notif_scan_mode_en.configure(this, 1, 3, "RW", 0, 'h0, 1, 1, 0);
            this.notif_soc_req_lock_en = new("notif_soc_req_lock_en");
            this.notif_soc_req_lock_en.configure(this, 1, 4, "RW", 0, 'h0, 1, 1, 0);
            this.notif_gen_in_toggle_en = new("notif_gen_in_toggle_en");
            this.notif_gen_in_toggle_en.configure(this, 1, 5, "RW", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(notif_cmd_avail_en_bit_cg[bt]) notif_cmd_avail_en_bit_cg[bt] = new();
                foreach(notif_mbox_ecc_cor_en_bit_cg[bt]) notif_mbox_ecc_cor_en_bit_cg[bt] = new();
                foreach(notif_debug_locked_en_bit_cg[bt]) notif_debug_locked_en_bit_cg[bt] = new();
                foreach(notif_scan_mode_en_bit_cg[bt]) notif_scan_mode_en_bit_cg[bt] = new();
                foreach(notif_soc_req_lock_en_bit_cg[bt]) notif_soc_req_lock_en_bit_cg[bt] = new();
                foreach(notif_gen_in_toggle_en_bit_cg[bt]) notif_gen_in_toggle_en_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__intr_block_t__notif_intr_en_t

    // Reg - soc_ifc_reg::intr_block_t::global_intr_t_agg_sts_dd3dcf0a
    class soc_ifc_reg__intr_block_t__global_intr_t_agg_sts_dd3dcf0a extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__intr_block_t__global_intr_t_agg_sts_dd3dcf0a_bit_cg agg_sts_bit_cg[1];
        soc_ifc_reg__intr_block_t__global_intr_t_agg_sts_dd3dcf0a_fld_cg fld_cg;
        rand uvm_reg_field agg_sts;

        function new(string name = "soc_ifc_reg__intr_block_t__global_intr_t_agg_sts_dd3dcf0a");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.agg_sts = new("agg_sts");
            this.agg_sts.configure(this, 1, 0, "RO", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(agg_sts_bit_cg[bt]) agg_sts_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__intr_block_t__global_intr_t_agg_sts_dd3dcf0a

    // Reg - soc_ifc_reg::intr_block_t::global_intr_t_agg_sts_e6399b4a
    class soc_ifc_reg__intr_block_t__global_intr_t_agg_sts_e6399b4a extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__intr_block_t__global_intr_t_agg_sts_e6399b4a_bit_cg agg_sts_bit_cg[1];
        soc_ifc_reg__intr_block_t__global_intr_t_agg_sts_e6399b4a_fld_cg fld_cg;
        rand uvm_reg_field agg_sts;

        function new(string name = "soc_ifc_reg__intr_block_t__global_intr_t_agg_sts_e6399b4a");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.agg_sts = new("agg_sts");
            this.agg_sts.configure(this, 1, 0, "RO", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(agg_sts_bit_cg[bt]) agg_sts_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__intr_block_t__global_intr_t_agg_sts_e6399b4a

    // Reg - soc_ifc_reg::intr_block_t::error_intr_t_error_bad_fuse_sts_23f67582_error_cmd_fail_sts_b85845f8_error_iccm_blocked_sts_e81e6ad2_error_internal_sts_caad62e2_error_inv_dev_sts_6693e7db_error_mbox_ecc_unc_sts_30bff330_error_wdt_timer1_timeout_sts_6aaa9655_error_wdt_timer2_timeout_sts_cda8789f
    class soc_ifc_reg__intr_block_t__error_intr_t_error_bad_fuse_sts_23f67582_error_cmd_fail_sts_b85845f8_error_iccm_blocked_sts_e81e6ad2_error_internal_sts_caad62e2_error_inv_dev_sts_6693e7db_error_mbox_ecc_unc_sts_30bff330_error_wdt_timer1_timeout_sts_6aaa9655_error_wdt_timer2_timeout_sts_cda8789f extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__intr_block_t__error_intr_t_error_bad_fuse_sts_23f67582_error_cmd_fail_sts_b85845f8_error_iccm_blocked_sts_e81e6ad2_error_internal_sts_caad62e2_error_inv_dev_sts_6693e7db_error_mbox_ecc_unc_sts_30bff330_error_wdt_timer1_timeout_sts_6aaa9655_error_wdt_timer2_timeout_sts_cda8789f_bit_cg error_internal_sts_bit_cg[1];
        soc_ifc_reg__intr_block_t__error_intr_t_error_bad_fuse_sts_23f67582_error_cmd_fail_sts_b85845f8_error_iccm_blocked_sts_e81e6ad2_error_internal_sts_caad62e2_error_inv_dev_sts_6693e7db_error_mbox_ecc_unc_sts_30bff330_error_wdt_timer1_timeout_sts_6aaa9655_error_wdt_timer2_timeout_sts_cda8789f_bit_cg error_inv_dev_sts_bit_cg[1];
        soc_ifc_reg__intr_block_t__error_intr_t_error_bad_fuse_sts_23f67582_error_cmd_fail_sts_b85845f8_error_iccm_blocked_sts_e81e6ad2_error_internal_sts_caad62e2_error_inv_dev_sts_6693e7db_error_mbox_ecc_unc_sts_30bff330_error_wdt_timer1_timeout_sts_6aaa9655_error_wdt_timer2_timeout_sts_cda8789f_bit_cg error_cmd_fail_sts_bit_cg[1];
        soc_ifc_reg__intr_block_t__error_intr_t_error_bad_fuse_sts_23f67582_error_cmd_fail_sts_b85845f8_error_iccm_blocked_sts_e81e6ad2_error_internal_sts_caad62e2_error_inv_dev_sts_6693e7db_error_mbox_ecc_unc_sts_30bff330_error_wdt_timer1_timeout_sts_6aaa9655_error_wdt_timer2_timeout_sts_cda8789f_bit_cg error_bad_fuse_sts_bit_cg[1];
        soc_ifc_reg__intr_block_t__error_intr_t_error_bad_fuse_sts_23f67582_error_cmd_fail_sts_b85845f8_error_iccm_blocked_sts_e81e6ad2_error_internal_sts_caad62e2_error_inv_dev_sts_6693e7db_error_mbox_ecc_unc_sts_30bff330_error_wdt_timer1_timeout_sts_6aaa9655_error_wdt_timer2_timeout_sts_cda8789f_bit_cg error_iccm_blocked_sts_bit_cg[1];
        soc_ifc_reg__intr_block_t__error_intr_t_error_bad_fuse_sts_23f67582_error_cmd_fail_sts_b85845f8_error_iccm_blocked_sts_e81e6ad2_error_internal_sts_caad62e2_error_inv_dev_sts_6693e7db_error_mbox_ecc_unc_sts_30bff330_error_wdt_timer1_timeout_sts_6aaa9655_error_wdt_timer2_timeout_sts_cda8789f_bit_cg error_mbox_ecc_unc_sts_bit_cg[1];
        soc_ifc_reg__intr_block_t__error_intr_t_error_bad_fuse_sts_23f67582_error_cmd_fail_sts_b85845f8_error_iccm_blocked_sts_e81e6ad2_error_internal_sts_caad62e2_error_inv_dev_sts_6693e7db_error_mbox_ecc_unc_sts_30bff330_error_wdt_timer1_timeout_sts_6aaa9655_error_wdt_timer2_timeout_sts_cda8789f_bit_cg error_wdt_timer1_timeout_sts_bit_cg[1];
        soc_ifc_reg__intr_block_t__error_intr_t_error_bad_fuse_sts_23f67582_error_cmd_fail_sts_b85845f8_error_iccm_blocked_sts_e81e6ad2_error_internal_sts_caad62e2_error_inv_dev_sts_6693e7db_error_mbox_ecc_unc_sts_30bff330_error_wdt_timer1_timeout_sts_6aaa9655_error_wdt_timer2_timeout_sts_cda8789f_bit_cg error_wdt_timer2_timeout_sts_bit_cg[1];
        soc_ifc_reg__intr_block_t__error_intr_t_error_bad_fuse_sts_23f67582_error_cmd_fail_sts_b85845f8_error_iccm_blocked_sts_e81e6ad2_error_internal_sts_caad62e2_error_inv_dev_sts_6693e7db_error_mbox_ecc_unc_sts_30bff330_error_wdt_timer1_timeout_sts_6aaa9655_error_wdt_timer2_timeout_sts_cda8789f_fld_cg fld_cg;
        rand uvm_reg_field error_internal_sts;
        rand uvm_reg_field error_inv_dev_sts;
        rand uvm_reg_field error_cmd_fail_sts;
        rand uvm_reg_field error_bad_fuse_sts;
        rand uvm_reg_field error_iccm_blocked_sts;
        rand uvm_reg_field error_mbox_ecc_unc_sts;
        rand uvm_reg_field error_wdt_timer1_timeout_sts;
        rand uvm_reg_field error_wdt_timer2_timeout_sts;

        function new(string name = "soc_ifc_reg__intr_block_t__error_intr_t_error_bad_fuse_sts_23f67582_error_cmd_fail_sts_b85845f8_error_iccm_blocked_sts_e81e6ad2_error_internal_sts_caad62e2_error_inv_dev_sts_6693e7db_error_mbox_ecc_unc_sts_30bff330_error_wdt_timer1_timeout_sts_6aaa9655_error_wdt_timer2_timeout_sts_cda8789f");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.error_internal_sts = new("error_internal_sts");
            this.error_internal_sts.configure(this, 1, 0, "W1C", 1, 'h0, 1, 1, 0);
            this.error_inv_dev_sts = new("error_inv_dev_sts");
            this.error_inv_dev_sts.configure(this, 1, 1, "W1C", 1, 'h0, 1, 1, 0);
            this.error_cmd_fail_sts = new("error_cmd_fail_sts");
            this.error_cmd_fail_sts.configure(this, 1, 2, "W1C", 1, 'h0, 1, 1, 0);
            this.error_bad_fuse_sts = new("error_bad_fuse_sts");
            this.error_bad_fuse_sts.configure(this, 1, 3, "W1C", 1, 'h0, 1, 1, 0);
            this.error_iccm_blocked_sts = new("error_iccm_blocked_sts");
            this.error_iccm_blocked_sts.configure(this, 1, 4, "W1C", 1, 'h0, 1, 1, 0);
            this.error_mbox_ecc_unc_sts = new("error_mbox_ecc_unc_sts");
            this.error_mbox_ecc_unc_sts.configure(this, 1, 5, "W1C", 1, 'h0, 1, 1, 0);
            this.error_wdt_timer1_timeout_sts = new("error_wdt_timer1_timeout_sts");
            this.error_wdt_timer1_timeout_sts.configure(this, 1, 6, "W1C", 1, 'h0, 1, 1, 0);
            this.error_wdt_timer2_timeout_sts = new("error_wdt_timer2_timeout_sts");
            this.error_wdt_timer2_timeout_sts.configure(this, 1, 7, "W1C", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(error_internal_sts_bit_cg[bt]) error_internal_sts_bit_cg[bt] = new();
                foreach(error_inv_dev_sts_bit_cg[bt]) error_inv_dev_sts_bit_cg[bt] = new();
                foreach(error_cmd_fail_sts_bit_cg[bt]) error_cmd_fail_sts_bit_cg[bt] = new();
                foreach(error_bad_fuse_sts_bit_cg[bt]) error_bad_fuse_sts_bit_cg[bt] = new();
                foreach(error_iccm_blocked_sts_bit_cg[bt]) error_iccm_blocked_sts_bit_cg[bt] = new();
                foreach(error_mbox_ecc_unc_sts_bit_cg[bt]) error_mbox_ecc_unc_sts_bit_cg[bt] = new();
                foreach(error_wdt_timer1_timeout_sts_bit_cg[bt]) error_wdt_timer1_timeout_sts_bit_cg[bt] = new();
                foreach(error_wdt_timer2_timeout_sts_bit_cg[bt]) error_wdt_timer2_timeout_sts_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__intr_block_t__error_intr_t_error_bad_fuse_sts_23f67582_error_cmd_fail_sts_b85845f8_error_iccm_blocked_sts_e81e6ad2_error_internal_sts_caad62e2_error_inv_dev_sts_6693e7db_error_mbox_ecc_unc_sts_30bff330_error_wdt_timer1_timeout_sts_6aaa9655_error_wdt_timer2_timeout_sts_cda8789f

    // Reg - soc_ifc_reg::intr_block_t::notif_intr_t_notif_cmd_avail_sts_1871606b_notif_debug_locked_sts_5f024102_notif_gen_in_toggle_sts_59f84b64_notif_mbox_ecc_cor_sts_5c3d26bb_notif_scan_mode_sts_122f6367_notif_soc_req_lock_sts_deddde70
    class soc_ifc_reg__intr_block_t__notif_intr_t_notif_cmd_avail_sts_1871606b_notif_debug_locked_sts_5f024102_notif_gen_in_toggle_sts_59f84b64_notif_mbox_ecc_cor_sts_5c3d26bb_notif_scan_mode_sts_122f6367_notif_soc_req_lock_sts_deddde70 extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__intr_block_t__notif_intr_t_notif_cmd_avail_sts_1871606b_notif_debug_locked_sts_5f024102_notif_gen_in_toggle_sts_59f84b64_notif_mbox_ecc_cor_sts_5c3d26bb_notif_scan_mode_sts_122f6367_notif_soc_req_lock_sts_deddde70_bit_cg notif_cmd_avail_sts_bit_cg[1];
        soc_ifc_reg__intr_block_t__notif_intr_t_notif_cmd_avail_sts_1871606b_notif_debug_locked_sts_5f024102_notif_gen_in_toggle_sts_59f84b64_notif_mbox_ecc_cor_sts_5c3d26bb_notif_scan_mode_sts_122f6367_notif_soc_req_lock_sts_deddde70_bit_cg notif_mbox_ecc_cor_sts_bit_cg[1];
        soc_ifc_reg__intr_block_t__notif_intr_t_notif_cmd_avail_sts_1871606b_notif_debug_locked_sts_5f024102_notif_gen_in_toggle_sts_59f84b64_notif_mbox_ecc_cor_sts_5c3d26bb_notif_scan_mode_sts_122f6367_notif_soc_req_lock_sts_deddde70_bit_cg notif_debug_locked_sts_bit_cg[1];
        soc_ifc_reg__intr_block_t__notif_intr_t_notif_cmd_avail_sts_1871606b_notif_debug_locked_sts_5f024102_notif_gen_in_toggle_sts_59f84b64_notif_mbox_ecc_cor_sts_5c3d26bb_notif_scan_mode_sts_122f6367_notif_soc_req_lock_sts_deddde70_bit_cg notif_scan_mode_sts_bit_cg[1];
        soc_ifc_reg__intr_block_t__notif_intr_t_notif_cmd_avail_sts_1871606b_notif_debug_locked_sts_5f024102_notif_gen_in_toggle_sts_59f84b64_notif_mbox_ecc_cor_sts_5c3d26bb_notif_scan_mode_sts_122f6367_notif_soc_req_lock_sts_deddde70_bit_cg notif_soc_req_lock_sts_bit_cg[1];
        soc_ifc_reg__intr_block_t__notif_intr_t_notif_cmd_avail_sts_1871606b_notif_debug_locked_sts_5f024102_notif_gen_in_toggle_sts_59f84b64_notif_mbox_ecc_cor_sts_5c3d26bb_notif_scan_mode_sts_122f6367_notif_soc_req_lock_sts_deddde70_bit_cg notif_gen_in_toggle_sts_bit_cg[1];
        soc_ifc_reg__intr_block_t__notif_intr_t_notif_cmd_avail_sts_1871606b_notif_debug_locked_sts_5f024102_notif_gen_in_toggle_sts_59f84b64_notif_mbox_ecc_cor_sts_5c3d26bb_notif_scan_mode_sts_122f6367_notif_soc_req_lock_sts_deddde70_fld_cg fld_cg;
        rand uvm_reg_field notif_cmd_avail_sts;
        rand uvm_reg_field notif_mbox_ecc_cor_sts;
        rand uvm_reg_field notif_debug_locked_sts;
        rand uvm_reg_field notif_scan_mode_sts;
        rand uvm_reg_field notif_soc_req_lock_sts;
        rand uvm_reg_field notif_gen_in_toggle_sts;

        function new(string name = "soc_ifc_reg__intr_block_t__notif_intr_t_notif_cmd_avail_sts_1871606b_notif_debug_locked_sts_5f024102_notif_gen_in_toggle_sts_59f84b64_notif_mbox_ecc_cor_sts_5c3d26bb_notif_scan_mode_sts_122f6367_notif_soc_req_lock_sts_deddde70");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.notif_cmd_avail_sts = new("notif_cmd_avail_sts");
            this.notif_cmd_avail_sts.configure(this, 1, 0, "W1C", 1, 'h0, 1, 1, 0);
            this.notif_mbox_ecc_cor_sts = new("notif_mbox_ecc_cor_sts");
            this.notif_mbox_ecc_cor_sts.configure(this, 1, 1, "W1C", 1, 'h0, 1, 1, 0);
            this.notif_debug_locked_sts = new("notif_debug_locked_sts");
            this.notif_debug_locked_sts.configure(this, 1, 2, "W1C", 1, 'h0, 1, 1, 0);
            this.notif_scan_mode_sts = new("notif_scan_mode_sts");
            this.notif_scan_mode_sts.configure(this, 1, 3, "W1C", 1, 'h0, 1, 1, 0);
            this.notif_soc_req_lock_sts = new("notif_soc_req_lock_sts");
            this.notif_soc_req_lock_sts.configure(this, 1, 4, "W1C", 1, 'h0, 1, 1, 0);
            this.notif_gen_in_toggle_sts = new("notif_gen_in_toggle_sts");
            this.notif_gen_in_toggle_sts.configure(this, 1, 5, "W1C", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(notif_cmd_avail_sts_bit_cg[bt]) notif_cmd_avail_sts_bit_cg[bt] = new();
                foreach(notif_mbox_ecc_cor_sts_bit_cg[bt]) notif_mbox_ecc_cor_sts_bit_cg[bt] = new();
                foreach(notif_debug_locked_sts_bit_cg[bt]) notif_debug_locked_sts_bit_cg[bt] = new();
                foreach(notif_scan_mode_sts_bit_cg[bt]) notif_scan_mode_sts_bit_cg[bt] = new();
                foreach(notif_soc_req_lock_sts_bit_cg[bt]) notif_soc_req_lock_sts_bit_cg[bt] = new();
                foreach(notif_gen_in_toggle_sts_bit_cg[bt]) notif_gen_in_toggle_sts_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__intr_block_t__notif_intr_t_notif_cmd_avail_sts_1871606b_notif_debug_locked_sts_5f024102_notif_gen_in_toggle_sts_59f84b64_notif_mbox_ecc_cor_sts_5c3d26bb_notif_scan_mode_sts_122f6367_notif_soc_req_lock_sts_deddde70

    // Reg - soc_ifc_reg::intr_block_t::error_intr_trig_t
    class soc_ifc_reg__intr_block_t__error_intr_trig_t extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__intr_block_t__error_intr_trig_t_bit_cg error_internal_trig_bit_cg[1];
        soc_ifc_reg__intr_block_t__error_intr_trig_t_bit_cg error_inv_dev_trig_bit_cg[1];
        soc_ifc_reg__intr_block_t__error_intr_trig_t_bit_cg error_cmd_fail_trig_bit_cg[1];
        soc_ifc_reg__intr_block_t__error_intr_trig_t_bit_cg error_bad_fuse_trig_bit_cg[1];
        soc_ifc_reg__intr_block_t__error_intr_trig_t_bit_cg error_iccm_blocked_trig_bit_cg[1];
        soc_ifc_reg__intr_block_t__error_intr_trig_t_bit_cg error_mbox_ecc_unc_trig_bit_cg[1];
        soc_ifc_reg__intr_block_t__error_intr_trig_t_bit_cg error_wdt_timer1_timeout_trig_bit_cg[1];
        soc_ifc_reg__intr_block_t__error_intr_trig_t_bit_cg error_wdt_timer2_timeout_trig_bit_cg[1];
        soc_ifc_reg__intr_block_t__error_intr_trig_t_fld_cg fld_cg;
        rand uvm_reg_field error_internal_trig;
        rand uvm_reg_field error_inv_dev_trig;
        rand uvm_reg_field error_cmd_fail_trig;
        rand uvm_reg_field error_bad_fuse_trig;
        rand uvm_reg_field error_iccm_blocked_trig;
        rand uvm_reg_field error_mbox_ecc_unc_trig;
        rand uvm_reg_field error_wdt_timer1_timeout_trig;
        rand uvm_reg_field error_wdt_timer2_timeout_trig;

        function new(string name = "soc_ifc_reg__intr_block_t__error_intr_trig_t");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.error_internal_trig = new("error_internal_trig");
            this.error_internal_trig.configure(this, 1, 0, "W1S", 0, 'h0, 1, 1, 0);
            this.error_inv_dev_trig = new("error_inv_dev_trig");
            this.error_inv_dev_trig.configure(this, 1, 1, "W1S", 0, 'h0, 1, 1, 0);
            this.error_cmd_fail_trig = new("error_cmd_fail_trig");
            this.error_cmd_fail_trig.configure(this, 1, 2, "W1S", 0, 'h0, 1, 1, 0);
            this.error_bad_fuse_trig = new("error_bad_fuse_trig");
            this.error_bad_fuse_trig.configure(this, 1, 3, "W1S", 0, 'h0, 1, 1, 0);
            this.error_iccm_blocked_trig = new("error_iccm_blocked_trig");
            this.error_iccm_blocked_trig.configure(this, 1, 4, "W1S", 0, 'h0, 1, 1, 0);
            this.error_mbox_ecc_unc_trig = new("error_mbox_ecc_unc_trig");
            this.error_mbox_ecc_unc_trig.configure(this, 1, 5, "W1S", 0, 'h0, 1, 1, 0);
            this.error_wdt_timer1_timeout_trig = new("error_wdt_timer1_timeout_trig");
            this.error_wdt_timer1_timeout_trig.configure(this, 1, 6, "W1S", 0, 'h0, 1, 1, 0);
            this.error_wdt_timer2_timeout_trig = new("error_wdt_timer2_timeout_trig");
            this.error_wdt_timer2_timeout_trig.configure(this, 1, 7, "W1S", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(error_internal_trig_bit_cg[bt]) error_internal_trig_bit_cg[bt] = new();
                foreach(error_inv_dev_trig_bit_cg[bt]) error_inv_dev_trig_bit_cg[bt] = new();
                foreach(error_cmd_fail_trig_bit_cg[bt]) error_cmd_fail_trig_bit_cg[bt] = new();
                foreach(error_bad_fuse_trig_bit_cg[bt]) error_bad_fuse_trig_bit_cg[bt] = new();
                foreach(error_iccm_blocked_trig_bit_cg[bt]) error_iccm_blocked_trig_bit_cg[bt] = new();
                foreach(error_mbox_ecc_unc_trig_bit_cg[bt]) error_mbox_ecc_unc_trig_bit_cg[bt] = new();
                foreach(error_wdt_timer1_timeout_trig_bit_cg[bt]) error_wdt_timer1_timeout_trig_bit_cg[bt] = new();
                foreach(error_wdt_timer2_timeout_trig_bit_cg[bt]) error_wdt_timer2_timeout_trig_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__intr_block_t__error_intr_trig_t

    // Reg - soc_ifc_reg::intr_block_t::notif_intr_trig_t
    class soc_ifc_reg__intr_block_t__notif_intr_trig_t extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__intr_block_t__notif_intr_trig_t_bit_cg notif_cmd_avail_trig_bit_cg[1];
        soc_ifc_reg__intr_block_t__notif_intr_trig_t_bit_cg notif_mbox_ecc_cor_trig_bit_cg[1];
        soc_ifc_reg__intr_block_t__notif_intr_trig_t_bit_cg notif_debug_locked_trig_bit_cg[1];
        soc_ifc_reg__intr_block_t__notif_intr_trig_t_bit_cg notif_scan_mode_trig_bit_cg[1];
        soc_ifc_reg__intr_block_t__notif_intr_trig_t_bit_cg notif_soc_req_lock_trig_bit_cg[1];
        soc_ifc_reg__intr_block_t__notif_intr_trig_t_bit_cg notif_gen_in_toggle_trig_bit_cg[1];
        soc_ifc_reg__intr_block_t__notif_intr_trig_t_fld_cg fld_cg;
        rand uvm_reg_field notif_cmd_avail_trig;
        rand uvm_reg_field notif_mbox_ecc_cor_trig;
        rand uvm_reg_field notif_debug_locked_trig;
        rand uvm_reg_field notif_scan_mode_trig;
        rand uvm_reg_field notif_soc_req_lock_trig;
        rand uvm_reg_field notif_gen_in_toggle_trig;

        function new(string name = "soc_ifc_reg__intr_block_t__notif_intr_trig_t");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.notif_cmd_avail_trig = new("notif_cmd_avail_trig");
            this.notif_cmd_avail_trig.configure(this, 1, 0, "W1S", 0, 'h0, 1, 1, 0);
            this.notif_mbox_ecc_cor_trig = new("notif_mbox_ecc_cor_trig");
            this.notif_mbox_ecc_cor_trig.configure(this, 1, 1, "W1S", 0, 'h0, 1, 1, 0);
            this.notif_debug_locked_trig = new("notif_debug_locked_trig");
            this.notif_debug_locked_trig.configure(this, 1, 2, "W1S", 0, 'h0, 1, 1, 0);
            this.notif_scan_mode_trig = new("notif_scan_mode_trig");
            this.notif_scan_mode_trig.configure(this, 1, 3, "W1S", 0, 'h0, 1, 1, 0);
            this.notif_soc_req_lock_trig = new("notif_soc_req_lock_trig");
            this.notif_soc_req_lock_trig.configure(this, 1, 4, "W1S", 0, 'h0, 1, 1, 0);
            this.notif_gen_in_toggle_trig = new("notif_gen_in_toggle_trig");
            this.notif_gen_in_toggle_trig.configure(this, 1, 5, "W1S", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(notif_cmd_avail_trig_bit_cg[bt]) notif_cmd_avail_trig_bit_cg[bt] = new();
                foreach(notif_mbox_ecc_cor_trig_bit_cg[bt]) notif_mbox_ecc_cor_trig_bit_cg[bt] = new();
                foreach(notif_debug_locked_trig_bit_cg[bt]) notif_debug_locked_trig_bit_cg[bt] = new();
                foreach(notif_scan_mode_trig_bit_cg[bt]) notif_scan_mode_trig_bit_cg[bt] = new();
                foreach(notif_soc_req_lock_trig_bit_cg[bt]) notif_soc_req_lock_trig_bit_cg[bt] = new();
                foreach(notif_gen_in_toggle_trig_bit_cg[bt]) notif_gen_in_toggle_trig_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__intr_block_t__notif_intr_trig_t

    // Reg - soc_ifc_reg::intr_block_t::intr_count_t_cnt_608f1141
    class soc_ifc_reg__intr_block_t__intr_count_t_cnt_608f1141 extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__intr_block_t__intr_count_t_cnt_608f1141_bit_cg cnt_bit_cg[32];
        soc_ifc_reg__intr_block_t__intr_count_t_cnt_608f1141_fld_cg fld_cg;
        rand uvm_reg_field cnt;

        function new(string name = "soc_ifc_reg__intr_block_t__intr_count_t_cnt_608f1141");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.cnt = new("cnt");
            this.cnt.configure(this, 32, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(cnt_bit_cg[bt]) cnt_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__intr_block_t__intr_count_t_cnt_608f1141

    // Reg - soc_ifc_reg::intr_block_t::intr_count_t_cnt_916ab5df
    class soc_ifc_reg__intr_block_t__intr_count_t_cnt_916ab5df extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__intr_block_t__intr_count_t_cnt_916ab5df_bit_cg cnt_bit_cg[32];
        soc_ifc_reg__intr_block_t__intr_count_t_cnt_916ab5df_fld_cg fld_cg;
        rand uvm_reg_field cnt;

        function new(string name = "soc_ifc_reg__intr_block_t__intr_count_t_cnt_916ab5df");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.cnt = new("cnt");
            this.cnt.configure(this, 32, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(cnt_bit_cg[bt]) cnt_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__intr_block_t__intr_count_t_cnt_916ab5df

    // Reg - soc_ifc_reg::intr_block_t::intr_count_t_cnt_b2a56031
    class soc_ifc_reg__intr_block_t__intr_count_t_cnt_b2a56031 extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__intr_block_t__intr_count_t_cnt_b2a56031_bit_cg cnt_bit_cg[32];
        soc_ifc_reg__intr_block_t__intr_count_t_cnt_b2a56031_fld_cg fld_cg;
        rand uvm_reg_field cnt;

        function new(string name = "soc_ifc_reg__intr_block_t__intr_count_t_cnt_b2a56031");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.cnt = new("cnt");
            this.cnt.configure(this, 32, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(cnt_bit_cg[bt]) cnt_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__intr_block_t__intr_count_t_cnt_b2a56031

    // Reg - soc_ifc_reg::intr_block_t::intr_count_t_cnt_fb7d2433
    class soc_ifc_reg__intr_block_t__intr_count_t_cnt_fb7d2433 extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__intr_block_t__intr_count_t_cnt_fb7d2433_bit_cg cnt_bit_cg[32];
        soc_ifc_reg__intr_block_t__intr_count_t_cnt_fb7d2433_fld_cg fld_cg;
        rand uvm_reg_field cnt;

        function new(string name = "soc_ifc_reg__intr_block_t__intr_count_t_cnt_fb7d2433");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.cnt = new("cnt");
            this.cnt.configure(this, 32, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(cnt_bit_cg[bt]) cnt_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__intr_block_t__intr_count_t_cnt_fb7d2433

    // Reg - soc_ifc_reg::intr_block_t::intr_count_t_cnt_25e76b6f
    class soc_ifc_reg__intr_block_t__intr_count_t_cnt_25e76b6f extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__intr_block_t__intr_count_t_cnt_25e76b6f_bit_cg cnt_bit_cg[32];
        soc_ifc_reg__intr_block_t__intr_count_t_cnt_25e76b6f_fld_cg fld_cg;
        rand uvm_reg_field cnt;

        function new(string name = "soc_ifc_reg__intr_block_t__intr_count_t_cnt_25e76b6f");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.cnt = new("cnt");
            this.cnt.configure(this, 32, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(cnt_bit_cg[bt]) cnt_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__intr_block_t__intr_count_t_cnt_25e76b6f

    // Reg - soc_ifc_reg::intr_block_t::intr_count_t_cnt_26b97e39
    class soc_ifc_reg__intr_block_t__intr_count_t_cnt_26b97e39 extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__intr_block_t__intr_count_t_cnt_26b97e39_bit_cg cnt_bit_cg[32];
        soc_ifc_reg__intr_block_t__intr_count_t_cnt_26b97e39_fld_cg fld_cg;
        rand uvm_reg_field cnt;

        function new(string name = "soc_ifc_reg__intr_block_t__intr_count_t_cnt_26b97e39");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.cnt = new("cnt");
            this.cnt.configure(this, 32, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(cnt_bit_cg[bt]) cnt_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__intr_block_t__intr_count_t_cnt_26b97e39

    // Reg - soc_ifc_reg::intr_block_t::intr_count_t_cnt_a2f61f82
    class soc_ifc_reg__intr_block_t__intr_count_t_cnt_a2f61f82 extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__intr_block_t__intr_count_t_cnt_a2f61f82_bit_cg cnt_bit_cg[32];
        soc_ifc_reg__intr_block_t__intr_count_t_cnt_a2f61f82_fld_cg fld_cg;
        rand uvm_reg_field cnt;

        function new(string name = "soc_ifc_reg__intr_block_t__intr_count_t_cnt_a2f61f82");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.cnt = new("cnt");
            this.cnt.configure(this, 32, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(cnt_bit_cg[bt]) cnt_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__intr_block_t__intr_count_t_cnt_a2f61f82

    // Reg - soc_ifc_reg::intr_block_t::intr_count_t_cnt_d46457cd
    class soc_ifc_reg__intr_block_t__intr_count_t_cnt_d46457cd extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__intr_block_t__intr_count_t_cnt_d46457cd_bit_cg cnt_bit_cg[32];
        soc_ifc_reg__intr_block_t__intr_count_t_cnt_d46457cd_fld_cg fld_cg;
        rand uvm_reg_field cnt;

        function new(string name = "soc_ifc_reg__intr_block_t__intr_count_t_cnt_d46457cd");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.cnt = new("cnt");
            this.cnt.configure(this, 32, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(cnt_bit_cg[bt]) cnt_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__intr_block_t__intr_count_t_cnt_d46457cd

    // Reg - soc_ifc_reg::intr_block_t::intr_count_t_cnt_a06f0954
    class soc_ifc_reg__intr_block_t__intr_count_t_cnt_a06f0954 extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__intr_block_t__intr_count_t_cnt_a06f0954_bit_cg cnt_bit_cg[32];
        soc_ifc_reg__intr_block_t__intr_count_t_cnt_a06f0954_fld_cg fld_cg;
        rand uvm_reg_field cnt;

        function new(string name = "soc_ifc_reg__intr_block_t__intr_count_t_cnt_a06f0954");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.cnt = new("cnt");
            this.cnt.configure(this, 32, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(cnt_bit_cg[bt]) cnt_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__intr_block_t__intr_count_t_cnt_a06f0954

    // Reg - soc_ifc_reg::intr_block_t::intr_count_t_cnt_00e49272
    class soc_ifc_reg__intr_block_t__intr_count_t_cnt_00e49272 extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__intr_block_t__intr_count_t_cnt_00e49272_bit_cg cnt_bit_cg[32];
        soc_ifc_reg__intr_block_t__intr_count_t_cnt_00e49272_fld_cg fld_cg;
        rand uvm_reg_field cnt;

        function new(string name = "soc_ifc_reg__intr_block_t__intr_count_t_cnt_00e49272");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.cnt = new("cnt");
            this.cnt.configure(this, 32, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(cnt_bit_cg[bt]) cnt_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__intr_block_t__intr_count_t_cnt_00e49272

    // Reg - soc_ifc_reg::intr_block_t::intr_count_t_cnt_ee53ded8
    class soc_ifc_reg__intr_block_t__intr_count_t_cnt_ee53ded8 extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__intr_block_t__intr_count_t_cnt_ee53ded8_bit_cg cnt_bit_cg[32];
        soc_ifc_reg__intr_block_t__intr_count_t_cnt_ee53ded8_fld_cg fld_cg;
        rand uvm_reg_field cnt;

        function new(string name = "soc_ifc_reg__intr_block_t__intr_count_t_cnt_ee53ded8");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.cnt = new("cnt");
            this.cnt.configure(this, 32, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(cnt_bit_cg[bt]) cnt_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__intr_block_t__intr_count_t_cnt_ee53ded8

    // Reg - soc_ifc_reg::intr_block_t::intr_count_t_cnt_fbf3c714
    class soc_ifc_reg__intr_block_t__intr_count_t_cnt_fbf3c714 extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__intr_block_t__intr_count_t_cnt_fbf3c714_bit_cg cnt_bit_cg[32];
        soc_ifc_reg__intr_block_t__intr_count_t_cnt_fbf3c714_fld_cg fld_cg;
        rand uvm_reg_field cnt;

        function new(string name = "soc_ifc_reg__intr_block_t__intr_count_t_cnt_fbf3c714");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.cnt = new("cnt");
            this.cnt.configure(this, 32, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(cnt_bit_cg[bt]) cnt_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__intr_block_t__intr_count_t_cnt_fbf3c714

    // Reg - soc_ifc_reg::intr_block_t::intr_count_t_cnt_b9bddabe
    class soc_ifc_reg__intr_block_t__intr_count_t_cnt_b9bddabe extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__intr_block_t__intr_count_t_cnt_b9bddabe_bit_cg cnt_bit_cg[32];
        soc_ifc_reg__intr_block_t__intr_count_t_cnt_b9bddabe_fld_cg fld_cg;
        rand uvm_reg_field cnt;

        function new(string name = "soc_ifc_reg__intr_block_t__intr_count_t_cnt_b9bddabe");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.cnt = new("cnt");
            this.cnt.configure(this, 32, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(cnt_bit_cg[bt]) cnt_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__intr_block_t__intr_count_t_cnt_b9bddabe

    // Reg - soc_ifc_reg::intr_block_t::intr_count_t_cnt_57528cc1
    class soc_ifc_reg__intr_block_t__intr_count_t_cnt_57528cc1 extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__intr_block_t__intr_count_t_cnt_57528cc1_bit_cg cnt_bit_cg[32];
        soc_ifc_reg__intr_block_t__intr_count_t_cnt_57528cc1_fld_cg fld_cg;
        rand uvm_reg_field cnt;

        function new(string name = "soc_ifc_reg__intr_block_t__intr_count_t_cnt_57528cc1");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.cnt = new("cnt");
            this.cnt.configure(this, 32, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(cnt_bit_cg[bt]) cnt_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__intr_block_t__intr_count_t_cnt_57528cc1

    // Reg - soc_ifc_reg::intr_block_t::intr_count_incr_t_pulse_15e6ed7e
    class soc_ifc_reg__intr_block_t__intr_count_incr_t_pulse_15e6ed7e extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__intr_block_t__intr_count_incr_t_pulse_15e6ed7e_bit_cg pulse_bit_cg[1];
        soc_ifc_reg__intr_block_t__intr_count_incr_t_pulse_15e6ed7e_fld_cg fld_cg;
        rand uvm_reg_field pulse;

        function new(string name = "soc_ifc_reg__intr_block_t__intr_count_incr_t_pulse_15e6ed7e");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.pulse = new("pulse");
            this.pulse.configure(this, 1, 0, "RO", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(pulse_bit_cg[bt]) pulse_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__intr_block_t__intr_count_incr_t_pulse_15e6ed7e

    // Reg - soc_ifc_reg::intr_block_t::intr_count_incr_t_pulse_f762ea9c
    class soc_ifc_reg__intr_block_t__intr_count_incr_t_pulse_f762ea9c extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__intr_block_t__intr_count_incr_t_pulse_f762ea9c_bit_cg pulse_bit_cg[1];
        soc_ifc_reg__intr_block_t__intr_count_incr_t_pulse_f762ea9c_fld_cg fld_cg;
        rand uvm_reg_field pulse;

        function new(string name = "soc_ifc_reg__intr_block_t__intr_count_incr_t_pulse_f762ea9c");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.pulse = new("pulse");
            this.pulse.configure(this, 1, 0, "RO", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(pulse_bit_cg[bt]) pulse_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__intr_block_t__intr_count_incr_t_pulse_f762ea9c

    // Reg - soc_ifc_reg::intr_block_t::intr_count_incr_t_pulse_aa8718c6
    class soc_ifc_reg__intr_block_t__intr_count_incr_t_pulse_aa8718c6 extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__intr_block_t__intr_count_incr_t_pulse_aa8718c6_bit_cg pulse_bit_cg[1];
        soc_ifc_reg__intr_block_t__intr_count_incr_t_pulse_aa8718c6_fld_cg fld_cg;
        rand uvm_reg_field pulse;

        function new(string name = "soc_ifc_reg__intr_block_t__intr_count_incr_t_pulse_aa8718c6");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.pulse = new("pulse");
            this.pulse.configure(this, 1, 0, "RO", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(pulse_bit_cg[bt]) pulse_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__intr_block_t__intr_count_incr_t_pulse_aa8718c6

    // Reg - soc_ifc_reg::intr_block_t::intr_count_incr_t_pulse_26fa5955
    class soc_ifc_reg__intr_block_t__intr_count_incr_t_pulse_26fa5955 extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__intr_block_t__intr_count_incr_t_pulse_26fa5955_bit_cg pulse_bit_cg[1];
        soc_ifc_reg__intr_block_t__intr_count_incr_t_pulse_26fa5955_fld_cg fld_cg;
        rand uvm_reg_field pulse;

        function new(string name = "soc_ifc_reg__intr_block_t__intr_count_incr_t_pulse_26fa5955");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.pulse = new("pulse");
            this.pulse.configure(this, 1, 0, "RO", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(pulse_bit_cg[bt]) pulse_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__intr_block_t__intr_count_incr_t_pulse_26fa5955

    // Reg - soc_ifc_reg::intr_block_t::intr_count_incr_t_pulse_3e43d258
    class soc_ifc_reg__intr_block_t__intr_count_incr_t_pulse_3e43d258 extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__intr_block_t__intr_count_incr_t_pulse_3e43d258_bit_cg pulse_bit_cg[1];
        soc_ifc_reg__intr_block_t__intr_count_incr_t_pulse_3e43d258_fld_cg fld_cg;
        rand uvm_reg_field pulse;

        function new(string name = "soc_ifc_reg__intr_block_t__intr_count_incr_t_pulse_3e43d258");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.pulse = new("pulse");
            this.pulse.configure(this, 1, 0, "RO", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(pulse_bit_cg[bt]) pulse_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__intr_block_t__intr_count_incr_t_pulse_3e43d258

    // Reg - soc_ifc_reg::intr_block_t::intr_count_incr_t_pulse_9f1632fd
    class soc_ifc_reg__intr_block_t__intr_count_incr_t_pulse_9f1632fd extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__intr_block_t__intr_count_incr_t_pulse_9f1632fd_bit_cg pulse_bit_cg[1];
        soc_ifc_reg__intr_block_t__intr_count_incr_t_pulse_9f1632fd_fld_cg fld_cg;
        rand uvm_reg_field pulse;

        function new(string name = "soc_ifc_reg__intr_block_t__intr_count_incr_t_pulse_9f1632fd");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.pulse = new("pulse");
            this.pulse.configure(this, 1, 0, "RO", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(pulse_bit_cg[bt]) pulse_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__intr_block_t__intr_count_incr_t_pulse_9f1632fd

    // Reg - soc_ifc_reg::intr_block_t::intr_count_incr_t_pulse_aa999fdc
    class soc_ifc_reg__intr_block_t__intr_count_incr_t_pulse_aa999fdc extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__intr_block_t__intr_count_incr_t_pulse_aa999fdc_bit_cg pulse_bit_cg[1];
        soc_ifc_reg__intr_block_t__intr_count_incr_t_pulse_aa999fdc_fld_cg fld_cg;
        rand uvm_reg_field pulse;

        function new(string name = "soc_ifc_reg__intr_block_t__intr_count_incr_t_pulse_aa999fdc");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.pulse = new("pulse");
            this.pulse.configure(this, 1, 0, "RO", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(pulse_bit_cg[bt]) pulse_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__intr_block_t__intr_count_incr_t_pulse_aa999fdc

    // Reg - soc_ifc_reg::intr_block_t::intr_count_incr_t_pulse_404e12db
    class soc_ifc_reg__intr_block_t__intr_count_incr_t_pulse_404e12db extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__intr_block_t__intr_count_incr_t_pulse_404e12db_bit_cg pulse_bit_cg[1];
        soc_ifc_reg__intr_block_t__intr_count_incr_t_pulse_404e12db_fld_cg fld_cg;
        rand uvm_reg_field pulse;

        function new(string name = "soc_ifc_reg__intr_block_t__intr_count_incr_t_pulse_404e12db");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.pulse = new("pulse");
            this.pulse.configure(this, 1, 0, "RO", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(pulse_bit_cg[bt]) pulse_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__intr_block_t__intr_count_incr_t_pulse_404e12db

    // Reg - soc_ifc_reg::intr_block_t::intr_count_incr_t_pulse_90d52137
    class soc_ifc_reg__intr_block_t__intr_count_incr_t_pulse_90d52137 extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__intr_block_t__intr_count_incr_t_pulse_90d52137_bit_cg pulse_bit_cg[1];
        soc_ifc_reg__intr_block_t__intr_count_incr_t_pulse_90d52137_fld_cg fld_cg;
        rand uvm_reg_field pulse;

        function new(string name = "soc_ifc_reg__intr_block_t__intr_count_incr_t_pulse_90d52137");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.pulse = new("pulse");
            this.pulse.configure(this, 1, 0, "RO", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(pulse_bit_cg[bt]) pulse_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__intr_block_t__intr_count_incr_t_pulse_90d52137

    // Reg - soc_ifc_reg::intr_block_t::intr_count_incr_t_pulse_a6db6fff
    class soc_ifc_reg__intr_block_t__intr_count_incr_t_pulse_a6db6fff extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__intr_block_t__intr_count_incr_t_pulse_a6db6fff_bit_cg pulse_bit_cg[1];
        soc_ifc_reg__intr_block_t__intr_count_incr_t_pulse_a6db6fff_fld_cg fld_cg;
        rand uvm_reg_field pulse;

        function new(string name = "soc_ifc_reg__intr_block_t__intr_count_incr_t_pulse_a6db6fff");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.pulse = new("pulse");
            this.pulse.configure(this, 1, 0, "RO", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(pulse_bit_cg[bt]) pulse_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__intr_block_t__intr_count_incr_t_pulse_a6db6fff

    // Reg - soc_ifc_reg::intr_block_t::intr_count_incr_t_pulse_51891fb1
    class soc_ifc_reg__intr_block_t__intr_count_incr_t_pulse_51891fb1 extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__intr_block_t__intr_count_incr_t_pulse_51891fb1_bit_cg pulse_bit_cg[1];
        soc_ifc_reg__intr_block_t__intr_count_incr_t_pulse_51891fb1_fld_cg fld_cg;
        rand uvm_reg_field pulse;

        function new(string name = "soc_ifc_reg__intr_block_t__intr_count_incr_t_pulse_51891fb1");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.pulse = new("pulse");
            this.pulse.configure(this, 1, 0, "RO", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(pulse_bit_cg[bt]) pulse_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__intr_block_t__intr_count_incr_t_pulse_51891fb1

    // Reg - soc_ifc_reg::intr_block_t::intr_count_incr_t_pulse_f5d8afe0
    class soc_ifc_reg__intr_block_t__intr_count_incr_t_pulse_f5d8afe0 extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__intr_block_t__intr_count_incr_t_pulse_f5d8afe0_bit_cg pulse_bit_cg[1];
        soc_ifc_reg__intr_block_t__intr_count_incr_t_pulse_f5d8afe0_fld_cg fld_cg;
        rand uvm_reg_field pulse;

        function new(string name = "soc_ifc_reg__intr_block_t__intr_count_incr_t_pulse_f5d8afe0");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.pulse = new("pulse");
            this.pulse.configure(this, 1, 0, "RO", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(pulse_bit_cg[bt]) pulse_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__intr_block_t__intr_count_incr_t_pulse_f5d8afe0

    // Reg - soc_ifc_reg::intr_block_t::intr_count_incr_t_pulse_246489bd
    class soc_ifc_reg__intr_block_t__intr_count_incr_t_pulse_246489bd extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__intr_block_t__intr_count_incr_t_pulse_246489bd_bit_cg pulse_bit_cg[1];
        soc_ifc_reg__intr_block_t__intr_count_incr_t_pulse_246489bd_fld_cg fld_cg;
        rand uvm_reg_field pulse;

        function new(string name = "soc_ifc_reg__intr_block_t__intr_count_incr_t_pulse_246489bd");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.pulse = new("pulse");
            this.pulse.configure(this, 1, 0, "RO", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(pulse_bit_cg[bt]) pulse_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__intr_block_t__intr_count_incr_t_pulse_246489bd

    // Reg - soc_ifc_reg::intr_block_t::intr_count_incr_t_pulse_d6ed4d1e
    class soc_ifc_reg__intr_block_t__intr_count_incr_t_pulse_d6ed4d1e extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        soc_ifc_reg__intr_block_t__intr_count_incr_t_pulse_d6ed4d1e_bit_cg pulse_bit_cg[1];
        soc_ifc_reg__intr_block_t__intr_count_incr_t_pulse_d6ed4d1e_fld_cg fld_cg;
        rand uvm_reg_field pulse;

        function new(string name = "soc_ifc_reg__intr_block_t__intr_count_incr_t_pulse_d6ed4d1e");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.pulse = new("pulse");
            this.pulse.configure(this, 1, 0, "RO", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(pulse_bit_cg[bt]) pulse_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : soc_ifc_reg__intr_block_t__intr_count_incr_t_pulse_d6ed4d1e

    // Regfile - soc_ifc_reg::intr_block_t
    class soc_ifc_reg__intr_block_t extends uvm_reg_block;
        rand soc_ifc_reg__intr_block_t__global_intr_en_t global_intr_en_r;
        rand soc_ifc_reg__intr_block_t__error_intr_en_t error_intr_en_r;
        rand soc_ifc_reg__intr_block_t__notif_intr_en_t notif_intr_en_r;
        rand soc_ifc_reg__intr_block_t__global_intr_t_agg_sts_dd3dcf0a error_global_intr_r;
        rand soc_ifc_reg__intr_block_t__global_intr_t_agg_sts_e6399b4a notif_global_intr_r;
        rand soc_ifc_reg__intr_block_t__error_intr_t_error_bad_fuse_sts_23f67582_error_cmd_fail_sts_b85845f8_error_iccm_blocked_sts_e81e6ad2_error_internal_sts_caad62e2_error_inv_dev_sts_6693e7db_error_mbox_ecc_unc_sts_30bff330_error_wdt_timer1_timeout_sts_6aaa9655_error_wdt_timer2_timeout_sts_cda8789f error_internal_intr_r;
        rand soc_ifc_reg__intr_block_t__notif_intr_t_notif_cmd_avail_sts_1871606b_notif_debug_locked_sts_5f024102_notif_gen_in_toggle_sts_59f84b64_notif_mbox_ecc_cor_sts_5c3d26bb_notif_scan_mode_sts_122f6367_notif_soc_req_lock_sts_deddde70 notif_internal_intr_r;
        rand soc_ifc_reg__intr_block_t__error_intr_trig_t error_intr_trig_r;
        rand soc_ifc_reg__intr_block_t__notif_intr_trig_t notif_intr_trig_r;
        rand soc_ifc_reg__intr_block_t__intr_count_t_cnt_608f1141 error_internal_intr_count_r;
        rand soc_ifc_reg__intr_block_t__intr_count_t_cnt_916ab5df error_inv_dev_intr_count_r;
        rand soc_ifc_reg__intr_block_t__intr_count_t_cnt_b2a56031 error_cmd_fail_intr_count_r;
        rand soc_ifc_reg__intr_block_t__intr_count_t_cnt_fb7d2433 error_bad_fuse_intr_count_r;
        rand soc_ifc_reg__intr_block_t__intr_count_t_cnt_25e76b6f error_iccm_blocked_intr_count_r;
        rand soc_ifc_reg__intr_block_t__intr_count_t_cnt_26b97e39 error_mbox_ecc_unc_intr_count_r;
        rand soc_ifc_reg__intr_block_t__intr_count_t_cnt_a2f61f82 error_wdt_timer1_timeout_intr_count_r;
        rand soc_ifc_reg__intr_block_t__intr_count_t_cnt_d46457cd error_wdt_timer2_timeout_intr_count_r;
        rand soc_ifc_reg__intr_block_t__intr_count_t_cnt_a06f0954 notif_cmd_avail_intr_count_r;
        rand soc_ifc_reg__intr_block_t__intr_count_t_cnt_00e49272 notif_mbox_ecc_cor_intr_count_r;
        rand soc_ifc_reg__intr_block_t__intr_count_t_cnt_ee53ded8 notif_debug_locked_intr_count_r;
        rand soc_ifc_reg__intr_block_t__intr_count_t_cnt_fbf3c714 notif_scan_mode_intr_count_r;
        rand soc_ifc_reg__intr_block_t__intr_count_t_cnt_b9bddabe notif_soc_req_lock_intr_count_r;
        rand soc_ifc_reg__intr_block_t__intr_count_t_cnt_57528cc1 notif_gen_in_toggle_intr_count_r;
        rand soc_ifc_reg__intr_block_t__intr_count_incr_t_pulse_15e6ed7e error_internal_intr_count_incr_r;
        rand soc_ifc_reg__intr_block_t__intr_count_incr_t_pulse_f762ea9c error_inv_dev_intr_count_incr_r;
        rand soc_ifc_reg__intr_block_t__intr_count_incr_t_pulse_aa8718c6 error_cmd_fail_intr_count_incr_r;
        rand soc_ifc_reg__intr_block_t__intr_count_incr_t_pulse_26fa5955 error_bad_fuse_intr_count_incr_r;
        rand soc_ifc_reg__intr_block_t__intr_count_incr_t_pulse_3e43d258 error_iccm_blocked_intr_count_incr_r;
        rand soc_ifc_reg__intr_block_t__intr_count_incr_t_pulse_9f1632fd error_mbox_ecc_unc_intr_count_incr_r;
        rand soc_ifc_reg__intr_block_t__intr_count_incr_t_pulse_aa999fdc error_wdt_timer1_timeout_intr_count_incr_r;
        rand soc_ifc_reg__intr_block_t__intr_count_incr_t_pulse_404e12db error_wdt_timer2_timeout_intr_count_incr_r;
        rand soc_ifc_reg__intr_block_t__intr_count_incr_t_pulse_90d52137 notif_cmd_avail_intr_count_incr_r;
        rand soc_ifc_reg__intr_block_t__intr_count_incr_t_pulse_a6db6fff notif_mbox_ecc_cor_intr_count_incr_r;
        rand soc_ifc_reg__intr_block_t__intr_count_incr_t_pulse_51891fb1 notif_debug_locked_intr_count_incr_r;
        rand soc_ifc_reg__intr_block_t__intr_count_incr_t_pulse_f5d8afe0 notif_scan_mode_intr_count_incr_r;
        rand soc_ifc_reg__intr_block_t__intr_count_incr_t_pulse_246489bd notif_soc_req_lock_intr_count_incr_r;
        rand soc_ifc_reg__intr_block_t__intr_count_incr_t_pulse_d6ed4d1e notif_gen_in_toggle_intr_count_incr_r;

        function new(string name = "soc_ifc_reg__intr_block_t");
            super.new(name);
        endfunction : new

        virtual function void build();
            this.default_map = create_map("reg_map", 0, 4, UVM_LITTLE_ENDIAN);
            this.global_intr_en_r = new("global_intr_en_r");
            this.global_intr_en_r.configure(this);

            this.global_intr_en_r.build();
            this.default_map.add_reg(this.global_intr_en_r, 'h0);
            this.error_intr_en_r = new("error_intr_en_r");
            this.error_intr_en_r.configure(this);

            this.error_intr_en_r.build();
            this.default_map.add_reg(this.error_intr_en_r, 'h4);
            this.notif_intr_en_r = new("notif_intr_en_r");
            this.notif_intr_en_r.configure(this);

            this.notif_intr_en_r.build();
            this.default_map.add_reg(this.notif_intr_en_r, 'h8);
            this.error_global_intr_r = new("error_global_intr_r");
            this.error_global_intr_r.configure(this);

            this.error_global_intr_r.build();
            this.default_map.add_reg(this.error_global_intr_r, 'hc);
            this.notif_global_intr_r = new("notif_global_intr_r");
            this.notif_global_intr_r.configure(this);

            this.notif_global_intr_r.build();
            this.default_map.add_reg(this.notif_global_intr_r, 'h10);
            this.error_internal_intr_r = new("error_internal_intr_r");
            this.error_internal_intr_r.configure(this);

            this.error_internal_intr_r.build();
            this.default_map.add_reg(this.error_internal_intr_r, 'h14);
            this.notif_internal_intr_r = new("notif_internal_intr_r");
            this.notif_internal_intr_r.configure(this);

            this.notif_internal_intr_r.build();
            this.default_map.add_reg(this.notif_internal_intr_r, 'h18);
            this.error_intr_trig_r = new("error_intr_trig_r");
            this.error_intr_trig_r.configure(this);

            this.error_intr_trig_r.build();
            this.default_map.add_reg(this.error_intr_trig_r, 'h1c);
            this.notif_intr_trig_r = new("notif_intr_trig_r");
            this.notif_intr_trig_r.configure(this);

            this.notif_intr_trig_r.build();
            this.default_map.add_reg(this.notif_intr_trig_r, 'h20);
            this.error_internal_intr_count_r = new("error_internal_intr_count_r");
            this.error_internal_intr_count_r.configure(this);

            this.error_internal_intr_count_r.build();
            this.default_map.add_reg(this.error_internal_intr_count_r, 'h100);
            this.error_inv_dev_intr_count_r = new("error_inv_dev_intr_count_r");
            this.error_inv_dev_intr_count_r.configure(this);

            this.error_inv_dev_intr_count_r.build();
            this.default_map.add_reg(this.error_inv_dev_intr_count_r, 'h104);
            this.error_cmd_fail_intr_count_r = new("error_cmd_fail_intr_count_r");
            this.error_cmd_fail_intr_count_r.configure(this);

            this.error_cmd_fail_intr_count_r.build();
            this.default_map.add_reg(this.error_cmd_fail_intr_count_r, 'h108);
            this.error_bad_fuse_intr_count_r = new("error_bad_fuse_intr_count_r");
            this.error_bad_fuse_intr_count_r.configure(this);

            this.error_bad_fuse_intr_count_r.build();
            this.default_map.add_reg(this.error_bad_fuse_intr_count_r, 'h10c);
            this.error_iccm_blocked_intr_count_r = new("error_iccm_blocked_intr_count_r");
            this.error_iccm_blocked_intr_count_r.configure(this);

            this.error_iccm_blocked_intr_count_r.build();
            this.default_map.add_reg(this.error_iccm_blocked_intr_count_r, 'h110);
            this.error_mbox_ecc_unc_intr_count_r = new("error_mbox_ecc_unc_intr_count_r");
            this.error_mbox_ecc_unc_intr_count_r.configure(this);

            this.error_mbox_ecc_unc_intr_count_r.build();
            this.default_map.add_reg(this.error_mbox_ecc_unc_intr_count_r, 'h114);
            this.error_wdt_timer1_timeout_intr_count_r = new("error_wdt_timer1_timeout_intr_count_r");
            this.error_wdt_timer1_timeout_intr_count_r.configure(this);

            this.error_wdt_timer1_timeout_intr_count_r.build();
            this.default_map.add_reg(this.error_wdt_timer1_timeout_intr_count_r, 'h118);
            this.error_wdt_timer2_timeout_intr_count_r = new("error_wdt_timer2_timeout_intr_count_r");
            this.error_wdt_timer2_timeout_intr_count_r.configure(this);

            this.error_wdt_timer2_timeout_intr_count_r.build();
            this.default_map.add_reg(this.error_wdt_timer2_timeout_intr_count_r, 'h11c);
            this.notif_cmd_avail_intr_count_r = new("notif_cmd_avail_intr_count_r");
            this.notif_cmd_avail_intr_count_r.configure(this);

            this.notif_cmd_avail_intr_count_r.build();
            this.default_map.add_reg(this.notif_cmd_avail_intr_count_r, 'h180);
            this.notif_mbox_ecc_cor_intr_count_r = new("notif_mbox_ecc_cor_intr_count_r");
            this.notif_mbox_ecc_cor_intr_count_r.configure(this);

            this.notif_mbox_ecc_cor_intr_count_r.build();
            this.default_map.add_reg(this.notif_mbox_ecc_cor_intr_count_r, 'h184);
            this.notif_debug_locked_intr_count_r = new("notif_debug_locked_intr_count_r");
            this.notif_debug_locked_intr_count_r.configure(this);

            this.notif_debug_locked_intr_count_r.build();
            this.default_map.add_reg(this.notif_debug_locked_intr_count_r, 'h188);
            this.notif_scan_mode_intr_count_r = new("notif_scan_mode_intr_count_r");
            this.notif_scan_mode_intr_count_r.configure(this);

            this.notif_scan_mode_intr_count_r.build();
            this.default_map.add_reg(this.notif_scan_mode_intr_count_r, 'h18c);
            this.notif_soc_req_lock_intr_count_r = new("notif_soc_req_lock_intr_count_r");
            this.notif_soc_req_lock_intr_count_r.configure(this);

            this.notif_soc_req_lock_intr_count_r.build();
            this.default_map.add_reg(this.notif_soc_req_lock_intr_count_r, 'h190);
            this.notif_gen_in_toggle_intr_count_r = new("notif_gen_in_toggle_intr_count_r");
            this.notif_gen_in_toggle_intr_count_r.configure(this);

            this.notif_gen_in_toggle_intr_count_r.build();
            this.default_map.add_reg(this.notif_gen_in_toggle_intr_count_r, 'h194);
            this.error_internal_intr_count_incr_r = new("error_internal_intr_count_incr_r");
            this.error_internal_intr_count_incr_r.configure(this);

            this.error_internal_intr_count_incr_r.build();
            this.default_map.add_reg(this.error_internal_intr_count_incr_r, 'h200);
            this.error_inv_dev_intr_count_incr_r = new("error_inv_dev_intr_count_incr_r");
            this.error_inv_dev_intr_count_incr_r.configure(this);

            this.error_inv_dev_intr_count_incr_r.build();
            this.default_map.add_reg(this.error_inv_dev_intr_count_incr_r, 'h204);
            this.error_cmd_fail_intr_count_incr_r = new("error_cmd_fail_intr_count_incr_r");
            this.error_cmd_fail_intr_count_incr_r.configure(this);

            this.error_cmd_fail_intr_count_incr_r.build();
            this.default_map.add_reg(this.error_cmd_fail_intr_count_incr_r, 'h208);
            this.error_bad_fuse_intr_count_incr_r = new("error_bad_fuse_intr_count_incr_r");
            this.error_bad_fuse_intr_count_incr_r.configure(this);

            this.error_bad_fuse_intr_count_incr_r.build();
            this.default_map.add_reg(this.error_bad_fuse_intr_count_incr_r, 'h20c);
            this.error_iccm_blocked_intr_count_incr_r = new("error_iccm_blocked_intr_count_incr_r");
            this.error_iccm_blocked_intr_count_incr_r.configure(this);

            this.error_iccm_blocked_intr_count_incr_r.build();
            this.default_map.add_reg(this.error_iccm_blocked_intr_count_incr_r, 'h210);
            this.error_mbox_ecc_unc_intr_count_incr_r = new("error_mbox_ecc_unc_intr_count_incr_r");
            this.error_mbox_ecc_unc_intr_count_incr_r.configure(this);

            this.error_mbox_ecc_unc_intr_count_incr_r.build();
            this.default_map.add_reg(this.error_mbox_ecc_unc_intr_count_incr_r, 'h214);
            this.error_wdt_timer1_timeout_intr_count_incr_r = new("error_wdt_timer1_timeout_intr_count_incr_r");
            this.error_wdt_timer1_timeout_intr_count_incr_r.configure(this);

            this.error_wdt_timer1_timeout_intr_count_incr_r.build();
            this.default_map.add_reg(this.error_wdt_timer1_timeout_intr_count_incr_r, 'h218);
            this.error_wdt_timer2_timeout_intr_count_incr_r = new("error_wdt_timer2_timeout_intr_count_incr_r");
            this.error_wdt_timer2_timeout_intr_count_incr_r.configure(this);

            this.error_wdt_timer2_timeout_intr_count_incr_r.build();
            this.default_map.add_reg(this.error_wdt_timer2_timeout_intr_count_incr_r, 'h21c);
            this.notif_cmd_avail_intr_count_incr_r = new("notif_cmd_avail_intr_count_incr_r");
            this.notif_cmd_avail_intr_count_incr_r.configure(this);

            this.notif_cmd_avail_intr_count_incr_r.build();
            this.default_map.add_reg(this.notif_cmd_avail_intr_count_incr_r, 'h220);
            this.notif_mbox_ecc_cor_intr_count_incr_r = new("notif_mbox_ecc_cor_intr_count_incr_r");
            this.notif_mbox_ecc_cor_intr_count_incr_r.configure(this);

            this.notif_mbox_ecc_cor_intr_count_incr_r.build();
            this.default_map.add_reg(this.notif_mbox_ecc_cor_intr_count_incr_r, 'h224);
            this.notif_debug_locked_intr_count_incr_r = new("notif_debug_locked_intr_count_incr_r");
            this.notif_debug_locked_intr_count_incr_r.configure(this);

            this.notif_debug_locked_intr_count_incr_r.build();
            this.default_map.add_reg(this.notif_debug_locked_intr_count_incr_r, 'h228);
            this.notif_scan_mode_intr_count_incr_r = new("notif_scan_mode_intr_count_incr_r");
            this.notif_scan_mode_intr_count_incr_r.configure(this);

            this.notif_scan_mode_intr_count_incr_r.build();
            this.default_map.add_reg(this.notif_scan_mode_intr_count_incr_r, 'h22c);
            this.notif_soc_req_lock_intr_count_incr_r = new("notif_soc_req_lock_intr_count_incr_r");
            this.notif_soc_req_lock_intr_count_incr_r.configure(this);

            this.notif_soc_req_lock_intr_count_incr_r.build();
            this.default_map.add_reg(this.notif_soc_req_lock_intr_count_incr_r, 'h230);
            this.notif_gen_in_toggle_intr_count_incr_r = new("notif_gen_in_toggle_intr_count_incr_r");
            this.notif_gen_in_toggle_intr_count_incr_r.configure(this);

            this.notif_gen_in_toggle_intr_count_incr_r.build();
            this.default_map.add_reg(this.notif_gen_in_toggle_intr_count_incr_r, 'h234);
        endfunction : build
    endclass : soc_ifc_reg__intr_block_t

    // Addrmap - soc_ifc_reg
    class soc_ifc_reg extends uvm_reg_block;
        rand soc_ifc_reg__CPTRA_HW_ERROR_FATAL CPTRA_HW_ERROR_FATAL;
        rand soc_ifc_reg__CPTRA_HW_ERROR_NON_FATAL CPTRA_HW_ERROR_NON_FATAL;
        rand soc_ifc_reg__CPTRA_FW_ERROR_FATAL CPTRA_FW_ERROR_FATAL;
        rand soc_ifc_reg__CPTRA_FW_ERROR_NON_FATAL CPTRA_FW_ERROR_NON_FATAL;
        rand soc_ifc_reg__CPTRA_HW_ERROR_ENC CPTRA_HW_ERROR_ENC;
        rand soc_ifc_reg__CPTRA_FW_ERROR_ENC CPTRA_FW_ERROR_ENC;
        rand soc_ifc_reg__CPTRA_FW_EXTENDED_ERROR_INFO CPTRA_FW_EXTENDED_ERROR_INFO[8];
        rand soc_ifc_reg__CPTRA_BOOT_STATUS CPTRA_BOOT_STATUS;
        rand soc_ifc_reg__CPTRA_FLOW_STATUS CPTRA_FLOW_STATUS;
        rand soc_ifc_reg__CPTRA_RESET_REASON CPTRA_RESET_REASON;
        rand soc_ifc_reg__CPTRA_SECURITY_STATE CPTRA_SECURITY_STATE;
        rand soc_ifc_reg__CPTRA_MBOX_VALID_AXI_USER CPTRA_MBOX_VALID_AXI_USER[5];
        rand soc_ifc_reg__CPTRA_MBOX_AXI_USER_LOCK CPTRA_MBOX_AXI_USER_LOCK[5];
        rand soc_ifc_reg__CPTRA_TRNG_VALID_AXI_USER CPTRA_TRNG_VALID_AXI_USER;
        rand soc_ifc_reg__CPTRA_TRNG_AXI_USER_LOCK CPTRA_TRNG_AXI_USER_LOCK;
        rand soc_ifc_reg__CPTRA_TRNG_DATA CPTRA_TRNG_DATA[12];
        rand soc_ifc_reg__CPTRA_TRNG_CTRL CPTRA_TRNG_CTRL;
        rand soc_ifc_reg__CPTRA_TRNG_STATUS CPTRA_TRNG_STATUS;
        rand soc_ifc_reg__CPTRA_FUSE_WR_DONE CPTRA_FUSE_WR_DONE;
        rand soc_ifc_reg__CPTRA_TIMER_CONFIG CPTRA_TIMER_CONFIG;
        rand soc_ifc_reg__CPTRA_BOOTFSM_GO CPTRA_BOOTFSM_GO;
        rand soc_ifc_reg__CPTRA_DBG_MANUF_SERVICE_REG CPTRA_DBG_MANUF_SERVICE_REG;
        rand soc_ifc_reg__CPTRA_CLK_GATING_EN CPTRA_CLK_GATING_EN;
        rand soc_ifc_reg__CPTRA_GENERIC_INPUT_WIRES CPTRA_GENERIC_INPUT_WIRES[2];
        rand soc_ifc_reg__CPTRA_GENERIC_OUTPUT_WIRES CPTRA_GENERIC_OUTPUT_WIRES[2];
        rand soc_ifc_reg__CPTRA_HW_REV_ID CPTRA_HW_REV_ID;
        rand soc_ifc_reg__CPTRA_FW_REV_ID CPTRA_FW_REV_ID[2];
        rand soc_ifc_reg__CPTRA_HW_CONFIG CPTRA_HW_CONFIG;
        rand soc_ifc_reg__CPTRA_WDT_TIMER1_EN CPTRA_WDT_TIMER1_EN;
        rand soc_ifc_reg__CPTRA_WDT_TIMER1_CTRL CPTRA_WDT_TIMER1_CTRL;
        rand soc_ifc_reg__CPTRA_WDT_TIMER1_TIMEOUT_PERIOD CPTRA_WDT_TIMER1_TIMEOUT_PERIOD[2];
        rand soc_ifc_reg__CPTRA_WDT_TIMER2_EN CPTRA_WDT_TIMER2_EN;
        rand soc_ifc_reg__CPTRA_WDT_TIMER2_CTRL CPTRA_WDT_TIMER2_CTRL;
        rand soc_ifc_reg__CPTRA_WDT_TIMER2_TIMEOUT_PERIOD CPTRA_WDT_TIMER2_TIMEOUT_PERIOD[2];
        rand soc_ifc_reg__CPTRA_WDT_STATUS CPTRA_WDT_STATUS;
        rand soc_ifc_reg__CPTRA_FUSE_VALID_AXI_USER CPTRA_FUSE_VALID_AXI_USER;
        rand soc_ifc_reg__CPTRA_FUSE_AXI_USER_LOCK CPTRA_FUSE_AXI_USER_LOCK;
        rand soc_ifc_reg__CPTRA_WDT_CFG CPTRA_WDT_CFG[2];
        rand soc_ifc_reg__CPTRA_iTRNG_ENTROPY_CONFIG_0 CPTRA_iTRNG_ENTROPY_CONFIG_0;
        rand soc_ifc_reg__CPTRA_iTRNG_ENTROPY_CONFIG_1 CPTRA_iTRNG_ENTROPY_CONFIG_1;
        rand soc_ifc_reg__CPTRA_RSVD_REG CPTRA_RSVD_REG[2];
        rand soc_ifc_reg__CPTRA_HW_CAPABILITIES CPTRA_HW_CAPABILITIES;
        rand soc_ifc_reg__CPTRA_FW_CAPABILITIES CPTRA_FW_CAPABILITIES;
        rand soc_ifc_reg__CPTRA_CAP_LOCK CPTRA_CAP_LOCK;
        rand soc_ifc_reg__CPTRA_OWNER_PK_HASH CPTRA_OWNER_PK_HASH[12];
        rand soc_ifc_reg__CPTRA_OWNER_PK_HASH_LOCK CPTRA_OWNER_PK_HASH_LOCK;
        rand soc_ifc_reg__fuse_uds_seed fuse_uds_seed[16];
        rand soc_ifc_reg__fuse_field_entropy fuse_field_entropy[8];
        rand soc_ifc_reg__fuse_key_manifest_pk_hash fuse_key_manifest_pk_hash[12];
        rand soc_ifc_reg__fuse_key_manifest_pk_hash_mask fuse_key_manifest_pk_hash_mask;
        rand soc_ifc_reg__fuse_fmc_key_manifest_svn fuse_fmc_key_manifest_svn;
        rand soc_ifc_reg__fuse_runtime_svn fuse_runtime_svn[4];
        rand soc_ifc_reg__fuse_anti_rollback_disable fuse_anti_rollback_disable;
        rand soc_ifc_reg__fuse_idevid_cert_attr fuse_idevid_cert_attr[24];
        rand soc_ifc_reg__fuse_idevid_manuf_hsm_id fuse_idevid_manuf_hsm_id[4];
        rand soc_ifc_reg__fuse_lms_revocation fuse_lms_revocation;
        rand soc_ifc_reg__fuse_mldsa_revocation fuse_mldsa_revocation;
        rand soc_ifc_reg__fuse_soc_stepping_id fuse_soc_stepping_id;
        rand soc_ifc_reg__fuse_manuf_dbg_unlock_token fuse_manuf_dbg_unlock_token[4];
        rand soc_ifc_reg__SS_CALIPTRA_BASE_ADDR_L SS_CALIPTRA_BASE_ADDR_L;
        rand soc_ifc_reg__SS_CALIPTRA_BASE_ADDR_H SS_CALIPTRA_BASE_ADDR_H;
        rand soc_ifc_reg__SS_MCI_BASE_ADDR_L SS_MCI_BASE_ADDR_L;
        rand soc_ifc_reg__SS_MCI_BASE_ADDR_H SS_MCI_BASE_ADDR_H;
        rand soc_ifc_reg__SS_RECOVERY_IFC_BASE_ADDR_L SS_RECOVERY_IFC_BASE_ADDR_L;
        rand soc_ifc_reg__SS_RECOVERY_IFC_BASE_ADDR_H SS_RECOVERY_IFC_BASE_ADDR_H;
        rand soc_ifc_reg__SS_OTP_FC_BASE_ADDR_L SS_OTP_FC_BASE_ADDR_L;
        rand soc_ifc_reg__SS_OTP_FC_BASE_ADDR_H SS_OTP_FC_BASE_ADDR_H;
        rand soc_ifc_reg__SS_UDS_SEED_BASE_ADDR_L SS_UDS_SEED_BASE_ADDR_L;
        rand soc_ifc_reg__SS_UDS_SEED_BASE_ADDR_H SS_UDS_SEED_BASE_ADDR_H;
        rand soc_ifc_reg__SS_PROD_DEBUG_UNLOCK_AUTH_PK_HASH_REG_BANK_OFFSET SS_PROD_DEBUG_UNLOCK_AUTH_PK_HASH_REG_BANK_OFFSET;
        rand soc_ifc_reg__SS_NUM_OF_PROD_DEBUG_UNLOCK_AUTH_PK_HASHES SS_NUM_OF_PROD_DEBUG_UNLOCK_AUTH_PK_HASHES;
        rand soc_ifc_reg__SS_DEBUG_INTENT SS_DEBUG_INTENT;
        rand soc_ifc_reg__SS_STRAP_GENERIC SS_STRAP_GENERIC[4];
        rand soc_ifc_reg__SS_DBG_MANUF_SERVICE_REG_REQ SS_DBG_MANUF_SERVICE_REG_REQ;
        rand soc_ifc_reg__SS_DBG_MANUF_SERVICE_REG_RSP SS_DBG_MANUF_SERVICE_REG_RSP;
        rand soc_ifc_reg__SS_SOC_DBG_UNLOCK_LEVEL SS_SOC_DBG_UNLOCK_LEVEL[2];
        rand soc_ifc_reg__SS_GENERIC_FW_EXEC_CTRL SS_GENERIC_FW_EXEC_CTRL[4];
        rand soc_ifc_reg__internal_obf_key internal_obf_key[8];
        rand soc_ifc_reg__internal_iccm_lock internal_iccm_lock;
        rand soc_ifc_reg__internal_fw_update_reset internal_fw_update_reset;
        rand soc_ifc_reg__internal_fw_update_reset_wait_cycles internal_fw_update_reset_wait_cycles;
        rand soc_ifc_reg__internal_nmi_vector internal_nmi_vector;
        rand soc_ifc_reg__internal_hw_error_fatal_mask internal_hw_error_fatal_mask;
        rand soc_ifc_reg__internal_hw_error_non_fatal_mask internal_hw_error_non_fatal_mask;
        rand soc_ifc_reg__internal_fw_error_fatal_mask internal_fw_error_fatal_mask;
        rand soc_ifc_reg__internal_fw_error_non_fatal_mask internal_fw_error_non_fatal_mask;
        rand soc_ifc_reg__internal_rv_mtime_l internal_rv_mtime_l;
        rand soc_ifc_reg__internal_rv_mtime_h internal_rv_mtime_h;
        rand soc_ifc_reg__internal_rv_mtimecmp_l internal_rv_mtimecmp_l;
        rand soc_ifc_reg__internal_rv_mtimecmp_h internal_rv_mtimecmp_h;
        rand soc_ifc_reg__intr_block_t intr_block_rf;

        function new(string name = "soc_ifc_reg");
            super.new(name);
        endfunction : new

        virtual function void build();
            this.default_map = create_map("reg_map", 0, 4, UVM_LITTLE_ENDIAN);
            this.CPTRA_HW_ERROR_FATAL = new("CPTRA_HW_ERROR_FATAL");
            this.CPTRA_HW_ERROR_FATAL.configure(this);

            this.CPTRA_HW_ERROR_FATAL.build();
            this.default_map.add_reg(this.CPTRA_HW_ERROR_FATAL, 'h0);
            this.CPTRA_HW_ERROR_NON_FATAL = new("CPTRA_HW_ERROR_NON_FATAL");
            this.CPTRA_HW_ERROR_NON_FATAL.configure(this);

            this.CPTRA_HW_ERROR_NON_FATAL.build();
            this.default_map.add_reg(this.CPTRA_HW_ERROR_NON_FATAL, 'h4);
            this.CPTRA_FW_ERROR_FATAL = new("CPTRA_FW_ERROR_FATAL");
            this.CPTRA_FW_ERROR_FATAL.configure(this);

            this.CPTRA_FW_ERROR_FATAL.build();
            this.default_map.add_reg(this.CPTRA_FW_ERROR_FATAL, 'h8);
            this.CPTRA_FW_ERROR_NON_FATAL = new("CPTRA_FW_ERROR_NON_FATAL");
            this.CPTRA_FW_ERROR_NON_FATAL.configure(this);

            this.CPTRA_FW_ERROR_NON_FATAL.build();
            this.default_map.add_reg(this.CPTRA_FW_ERROR_NON_FATAL, 'hc);
            this.CPTRA_HW_ERROR_ENC = new("CPTRA_HW_ERROR_ENC");
            this.CPTRA_HW_ERROR_ENC.configure(this);

            this.CPTRA_HW_ERROR_ENC.build();
            this.default_map.add_reg(this.CPTRA_HW_ERROR_ENC, 'h10);
            this.CPTRA_FW_ERROR_ENC = new("CPTRA_FW_ERROR_ENC");
            this.CPTRA_FW_ERROR_ENC.configure(this);

            this.CPTRA_FW_ERROR_ENC.build();
            this.default_map.add_reg(this.CPTRA_FW_ERROR_ENC, 'h14);
            foreach(this.CPTRA_FW_EXTENDED_ERROR_INFO[i0]) begin
                this.CPTRA_FW_EXTENDED_ERROR_INFO[i0] = new($sformatf("CPTRA_FW_EXTENDED_ERROR_INFO[%0d]", i0));
                this.CPTRA_FW_EXTENDED_ERROR_INFO[i0].configure(this);
                
                this.CPTRA_FW_EXTENDED_ERROR_INFO[i0].build();
                this.default_map.add_reg(this.CPTRA_FW_EXTENDED_ERROR_INFO[i0], 'h18 + i0*'h4);
            end
            this.CPTRA_BOOT_STATUS = new("CPTRA_BOOT_STATUS");
            this.CPTRA_BOOT_STATUS.configure(this);

            this.CPTRA_BOOT_STATUS.build();
            this.default_map.add_reg(this.CPTRA_BOOT_STATUS, 'h38);
            this.CPTRA_FLOW_STATUS = new("CPTRA_FLOW_STATUS");
            this.CPTRA_FLOW_STATUS.configure(this);

            this.CPTRA_FLOW_STATUS.build();
            this.default_map.add_reg(this.CPTRA_FLOW_STATUS, 'h3c);
            this.CPTRA_RESET_REASON = new("CPTRA_RESET_REASON");
            this.CPTRA_RESET_REASON.configure(this);

            this.CPTRA_RESET_REASON.build();
            this.default_map.add_reg(this.CPTRA_RESET_REASON, 'h40);
            this.CPTRA_SECURITY_STATE = new("CPTRA_SECURITY_STATE");
            this.CPTRA_SECURITY_STATE.configure(this);

            this.CPTRA_SECURITY_STATE.build();
            this.default_map.add_reg(this.CPTRA_SECURITY_STATE, 'h44);
            foreach(this.CPTRA_MBOX_VALID_AXI_USER[i0]) begin
                this.CPTRA_MBOX_VALID_AXI_USER[i0] = new($sformatf("CPTRA_MBOX_VALID_AXI_USER[%0d]", i0));
                this.CPTRA_MBOX_VALID_AXI_USER[i0].configure(this);
                
                this.CPTRA_MBOX_VALID_AXI_USER[i0].build();
                this.default_map.add_reg(this.CPTRA_MBOX_VALID_AXI_USER[i0], 'h48 + i0*'h4);
            end
            foreach(this.CPTRA_MBOX_AXI_USER_LOCK[i0]) begin
                this.CPTRA_MBOX_AXI_USER_LOCK[i0] = new($sformatf("CPTRA_MBOX_AXI_USER_LOCK[%0d]", i0));
                this.CPTRA_MBOX_AXI_USER_LOCK[i0].configure(this);
                
                this.CPTRA_MBOX_AXI_USER_LOCK[i0].build();
                this.default_map.add_reg(this.CPTRA_MBOX_AXI_USER_LOCK[i0], 'h5c + i0*'h4);
            end
            this.CPTRA_TRNG_VALID_AXI_USER = new("CPTRA_TRNG_VALID_AXI_USER");
            this.CPTRA_TRNG_VALID_AXI_USER.configure(this);

            this.CPTRA_TRNG_VALID_AXI_USER.build();
            this.default_map.add_reg(this.CPTRA_TRNG_VALID_AXI_USER, 'h70);
            this.CPTRA_TRNG_AXI_USER_LOCK = new("CPTRA_TRNG_AXI_USER_LOCK");
            this.CPTRA_TRNG_AXI_USER_LOCK.configure(this);

            this.CPTRA_TRNG_AXI_USER_LOCK.build();
            this.default_map.add_reg(this.CPTRA_TRNG_AXI_USER_LOCK, 'h74);
            foreach(this.CPTRA_TRNG_DATA[i0]) begin
                this.CPTRA_TRNG_DATA[i0] = new($sformatf("CPTRA_TRNG_DATA[%0d]", i0));
                this.CPTRA_TRNG_DATA[i0].configure(this);
                
                this.CPTRA_TRNG_DATA[i0].build();
                this.default_map.add_reg(this.CPTRA_TRNG_DATA[i0], 'h78 + i0*'h4);
            end
            this.CPTRA_TRNG_CTRL = new("CPTRA_TRNG_CTRL");
            this.CPTRA_TRNG_CTRL.configure(this);

            this.CPTRA_TRNG_CTRL.build();
            this.default_map.add_reg(this.CPTRA_TRNG_CTRL, 'ha8);
            this.CPTRA_TRNG_STATUS = new("CPTRA_TRNG_STATUS");
            this.CPTRA_TRNG_STATUS.configure(this);

            this.CPTRA_TRNG_STATUS.build();
            this.default_map.add_reg(this.CPTRA_TRNG_STATUS, 'hac);
            this.CPTRA_FUSE_WR_DONE = new("CPTRA_FUSE_WR_DONE");
            this.CPTRA_FUSE_WR_DONE.configure(this);

            this.CPTRA_FUSE_WR_DONE.build();
            this.default_map.add_reg(this.CPTRA_FUSE_WR_DONE, 'hb0);
            this.CPTRA_TIMER_CONFIG = new("CPTRA_TIMER_CONFIG");
            this.CPTRA_TIMER_CONFIG.configure(this);

            this.CPTRA_TIMER_CONFIG.build();
            this.default_map.add_reg(this.CPTRA_TIMER_CONFIG, 'hb4);
            this.CPTRA_BOOTFSM_GO = new("CPTRA_BOOTFSM_GO");
            this.CPTRA_BOOTFSM_GO.configure(this);

            this.CPTRA_BOOTFSM_GO.build();
            this.default_map.add_reg(this.CPTRA_BOOTFSM_GO, 'hb8);
            this.CPTRA_DBG_MANUF_SERVICE_REG = new("CPTRA_DBG_MANUF_SERVICE_REG");
            this.CPTRA_DBG_MANUF_SERVICE_REG.configure(this);

            this.CPTRA_DBG_MANUF_SERVICE_REG.build();
            this.default_map.add_reg(this.CPTRA_DBG_MANUF_SERVICE_REG, 'hbc);
            this.CPTRA_CLK_GATING_EN = new("CPTRA_CLK_GATING_EN");
            this.CPTRA_CLK_GATING_EN.configure(this);

            this.CPTRA_CLK_GATING_EN.build();
            this.default_map.add_reg(this.CPTRA_CLK_GATING_EN, 'hc0);
            foreach(this.CPTRA_GENERIC_INPUT_WIRES[i0]) begin
                this.CPTRA_GENERIC_INPUT_WIRES[i0] = new($sformatf("CPTRA_GENERIC_INPUT_WIRES[%0d]", i0));
                this.CPTRA_GENERIC_INPUT_WIRES[i0].configure(this);
                
                this.CPTRA_GENERIC_INPUT_WIRES[i0].build();
                this.default_map.add_reg(this.CPTRA_GENERIC_INPUT_WIRES[i0], 'hc4 + i0*'h4);
            end
            foreach(this.CPTRA_GENERIC_OUTPUT_WIRES[i0]) begin
                this.CPTRA_GENERIC_OUTPUT_WIRES[i0] = new($sformatf("CPTRA_GENERIC_OUTPUT_WIRES[%0d]", i0));
                this.CPTRA_GENERIC_OUTPUT_WIRES[i0].configure(this);
                
                this.CPTRA_GENERIC_OUTPUT_WIRES[i0].build();
                this.default_map.add_reg(this.CPTRA_GENERIC_OUTPUT_WIRES[i0], 'hcc + i0*'h4);
            end
            this.CPTRA_HW_REV_ID = new("CPTRA_HW_REV_ID");
            this.CPTRA_HW_REV_ID.configure(this);

            this.CPTRA_HW_REV_ID.build();
            this.default_map.add_reg(this.CPTRA_HW_REV_ID, 'hd4);
            foreach(this.CPTRA_FW_REV_ID[i0]) begin
                this.CPTRA_FW_REV_ID[i0] = new($sformatf("CPTRA_FW_REV_ID[%0d]", i0));
                this.CPTRA_FW_REV_ID[i0].configure(this);
                
                this.CPTRA_FW_REV_ID[i0].build();
                this.default_map.add_reg(this.CPTRA_FW_REV_ID[i0], 'hd8 + i0*'h4);
            end
            this.CPTRA_HW_CONFIG = new("CPTRA_HW_CONFIG");
            this.CPTRA_HW_CONFIG.configure(this);

            this.CPTRA_HW_CONFIG.build();
            this.default_map.add_reg(this.CPTRA_HW_CONFIG, 'he0);
            this.CPTRA_WDT_TIMER1_EN = new("CPTRA_WDT_TIMER1_EN");
            this.CPTRA_WDT_TIMER1_EN.configure(this);

            this.CPTRA_WDT_TIMER1_EN.build();
            this.default_map.add_reg(this.CPTRA_WDT_TIMER1_EN, 'he4);
            this.CPTRA_WDT_TIMER1_CTRL = new("CPTRA_WDT_TIMER1_CTRL");
            this.CPTRA_WDT_TIMER1_CTRL.configure(this);

            this.CPTRA_WDT_TIMER1_CTRL.build();
            this.default_map.add_reg(this.CPTRA_WDT_TIMER1_CTRL, 'he8);
            foreach(this.CPTRA_WDT_TIMER1_TIMEOUT_PERIOD[i0]) begin
                this.CPTRA_WDT_TIMER1_TIMEOUT_PERIOD[i0] = new($sformatf("CPTRA_WDT_TIMER1_TIMEOUT_PERIOD[%0d]", i0));
                this.CPTRA_WDT_TIMER1_TIMEOUT_PERIOD[i0].configure(this);
                
                this.CPTRA_WDT_TIMER1_TIMEOUT_PERIOD[i0].build();
                this.default_map.add_reg(this.CPTRA_WDT_TIMER1_TIMEOUT_PERIOD[i0], 'hec + i0*'h4);
            end
            this.CPTRA_WDT_TIMER2_EN = new("CPTRA_WDT_TIMER2_EN");
            this.CPTRA_WDT_TIMER2_EN.configure(this);

            this.CPTRA_WDT_TIMER2_EN.build();
            this.default_map.add_reg(this.CPTRA_WDT_TIMER2_EN, 'hf4);
            this.CPTRA_WDT_TIMER2_CTRL = new("CPTRA_WDT_TIMER2_CTRL");
            this.CPTRA_WDT_TIMER2_CTRL.configure(this);

            this.CPTRA_WDT_TIMER2_CTRL.build();
            this.default_map.add_reg(this.CPTRA_WDT_TIMER2_CTRL, 'hf8);
            foreach(this.CPTRA_WDT_TIMER2_TIMEOUT_PERIOD[i0]) begin
                this.CPTRA_WDT_TIMER2_TIMEOUT_PERIOD[i0] = new($sformatf("CPTRA_WDT_TIMER2_TIMEOUT_PERIOD[%0d]", i0));
                this.CPTRA_WDT_TIMER2_TIMEOUT_PERIOD[i0].configure(this);
                
                this.CPTRA_WDT_TIMER2_TIMEOUT_PERIOD[i0].build();
                this.default_map.add_reg(this.CPTRA_WDT_TIMER2_TIMEOUT_PERIOD[i0], 'hfc + i0*'h4);
            end
            this.CPTRA_WDT_STATUS = new("CPTRA_WDT_STATUS");
            this.CPTRA_WDT_STATUS.configure(this);

            this.CPTRA_WDT_STATUS.build();
            this.default_map.add_reg(this.CPTRA_WDT_STATUS, 'h104);
            this.CPTRA_FUSE_VALID_AXI_USER = new("CPTRA_FUSE_VALID_AXI_USER");
            this.CPTRA_FUSE_VALID_AXI_USER.configure(this);

            this.CPTRA_FUSE_VALID_AXI_USER.build();
            this.default_map.add_reg(this.CPTRA_FUSE_VALID_AXI_USER, 'h108);
            this.CPTRA_FUSE_AXI_USER_LOCK = new("CPTRA_FUSE_AXI_USER_LOCK");
            this.CPTRA_FUSE_AXI_USER_LOCK.configure(this);

            this.CPTRA_FUSE_AXI_USER_LOCK.build();
            this.default_map.add_reg(this.CPTRA_FUSE_AXI_USER_LOCK, 'h10c);
            foreach(this.CPTRA_WDT_CFG[i0]) begin
                this.CPTRA_WDT_CFG[i0] = new($sformatf("CPTRA_WDT_CFG[%0d]", i0));
                this.CPTRA_WDT_CFG[i0].configure(this);
                
                this.CPTRA_WDT_CFG[i0].build();
                this.default_map.add_reg(this.CPTRA_WDT_CFG[i0], 'h110 + i0*'h4);
            end
            this.CPTRA_iTRNG_ENTROPY_CONFIG_0 = new("CPTRA_iTRNG_ENTROPY_CONFIG_0");
            this.CPTRA_iTRNG_ENTROPY_CONFIG_0.configure(this);

            this.CPTRA_iTRNG_ENTROPY_CONFIG_0.build();
            this.default_map.add_reg(this.CPTRA_iTRNG_ENTROPY_CONFIG_0, 'h118);
            this.CPTRA_iTRNG_ENTROPY_CONFIG_1 = new("CPTRA_iTRNG_ENTROPY_CONFIG_1");
            this.CPTRA_iTRNG_ENTROPY_CONFIG_1.configure(this);

            this.CPTRA_iTRNG_ENTROPY_CONFIG_1.build();
            this.default_map.add_reg(this.CPTRA_iTRNG_ENTROPY_CONFIG_1, 'h11c);
            foreach(this.CPTRA_RSVD_REG[i0]) begin
                this.CPTRA_RSVD_REG[i0] = new($sformatf("CPTRA_RSVD_REG[%0d]", i0));
                this.CPTRA_RSVD_REG[i0].configure(this);
                
                this.CPTRA_RSVD_REG[i0].build();
                this.default_map.add_reg(this.CPTRA_RSVD_REG[i0], 'h120 + i0*'h4);
            end
            this.CPTRA_HW_CAPABILITIES = new("CPTRA_HW_CAPABILITIES");
            this.CPTRA_HW_CAPABILITIES.configure(this);

            this.CPTRA_HW_CAPABILITIES.build();
            this.default_map.add_reg(this.CPTRA_HW_CAPABILITIES, 'h128);
            this.CPTRA_FW_CAPABILITIES = new("CPTRA_FW_CAPABILITIES");
            this.CPTRA_FW_CAPABILITIES.configure(this);

            this.CPTRA_FW_CAPABILITIES.build();
            this.default_map.add_reg(this.CPTRA_FW_CAPABILITIES, 'h12c);
            this.CPTRA_CAP_LOCK = new("CPTRA_CAP_LOCK");
            this.CPTRA_CAP_LOCK.configure(this);

            this.CPTRA_CAP_LOCK.build();
            this.default_map.add_reg(this.CPTRA_CAP_LOCK, 'h130);
            foreach(this.CPTRA_OWNER_PK_HASH[i0]) begin
                this.CPTRA_OWNER_PK_HASH[i0] = new($sformatf("CPTRA_OWNER_PK_HASH[%0d]", i0));
                this.CPTRA_OWNER_PK_HASH[i0].configure(this);
                
                this.CPTRA_OWNER_PK_HASH[i0].build();
                this.default_map.add_reg(this.CPTRA_OWNER_PK_HASH[i0], 'h140 + i0*'h4);
            end
            this.CPTRA_OWNER_PK_HASH_LOCK = new("CPTRA_OWNER_PK_HASH_LOCK");
            this.CPTRA_OWNER_PK_HASH_LOCK.configure(this);

            this.CPTRA_OWNER_PK_HASH_LOCK.build();
            this.default_map.add_reg(this.CPTRA_OWNER_PK_HASH_LOCK, 'h170);
            foreach(this.fuse_uds_seed[i0]) begin
                this.fuse_uds_seed[i0] = new($sformatf("fuse_uds_seed[%0d]", i0));
                this.fuse_uds_seed[i0].configure(this);
                
                this.fuse_uds_seed[i0].build();
                this.default_map.add_reg(this.fuse_uds_seed[i0], 'h200 + i0*'h4);
            end
            foreach(this.fuse_field_entropy[i0]) begin
                this.fuse_field_entropy[i0] = new($sformatf("fuse_field_entropy[%0d]", i0));
                this.fuse_field_entropy[i0].configure(this);
                
                this.fuse_field_entropy[i0].build();
                this.default_map.add_reg(this.fuse_field_entropy[i0], 'h240 + i0*'h4);
            end
            foreach(this.fuse_key_manifest_pk_hash[i0]) begin
                this.fuse_key_manifest_pk_hash[i0] = new($sformatf("fuse_key_manifest_pk_hash[%0d]", i0));
                this.fuse_key_manifest_pk_hash[i0].configure(this);
                
                this.fuse_key_manifest_pk_hash[i0].build();
                this.default_map.add_reg(this.fuse_key_manifest_pk_hash[i0], 'h260 + i0*'h4);
            end
            this.fuse_key_manifest_pk_hash_mask = new("fuse_key_manifest_pk_hash_mask");
            this.fuse_key_manifest_pk_hash_mask.configure(this);

            this.fuse_key_manifest_pk_hash_mask.build();
            this.default_map.add_reg(this.fuse_key_manifest_pk_hash_mask, 'h290);
            this.fuse_fmc_key_manifest_svn = new("fuse_fmc_key_manifest_svn");
            this.fuse_fmc_key_manifest_svn.configure(this);

            this.fuse_fmc_key_manifest_svn.build();
            this.default_map.add_reg(this.fuse_fmc_key_manifest_svn, 'h2b4);
            foreach(this.fuse_runtime_svn[i0]) begin
                this.fuse_runtime_svn[i0] = new($sformatf("fuse_runtime_svn[%0d]", i0));
                this.fuse_runtime_svn[i0].configure(this);
                
                this.fuse_runtime_svn[i0].build();
                this.default_map.add_reg(this.fuse_runtime_svn[i0], 'h2b8 + i0*'h4);
            end
            this.fuse_anti_rollback_disable = new("fuse_anti_rollback_disable");
            this.fuse_anti_rollback_disable.configure(this);

            this.fuse_anti_rollback_disable.build();
            this.default_map.add_reg(this.fuse_anti_rollback_disable, 'h2c8);
            foreach(this.fuse_idevid_cert_attr[i0]) begin
                this.fuse_idevid_cert_attr[i0] = new($sformatf("fuse_idevid_cert_attr[%0d]", i0));
                this.fuse_idevid_cert_attr[i0].configure(this);
                
                this.fuse_idevid_cert_attr[i0].build();
                this.default_map.add_reg(this.fuse_idevid_cert_attr[i0], 'h2cc + i0*'h4);
            end
            foreach(this.fuse_idevid_manuf_hsm_id[i0]) begin
                this.fuse_idevid_manuf_hsm_id[i0] = new($sformatf("fuse_idevid_manuf_hsm_id[%0d]", i0));
                this.fuse_idevid_manuf_hsm_id[i0].configure(this);
                
                this.fuse_idevid_manuf_hsm_id[i0].build();
                this.default_map.add_reg(this.fuse_idevid_manuf_hsm_id[i0], 'h32c + i0*'h4);
            end
            this.fuse_lms_revocation = new("fuse_lms_revocation");
            this.fuse_lms_revocation.configure(this);

            this.fuse_lms_revocation.build();
            this.default_map.add_reg(this.fuse_lms_revocation, 'h340);
            this.fuse_mldsa_revocation = new("fuse_mldsa_revocation");
            this.fuse_mldsa_revocation.configure(this);

            this.fuse_mldsa_revocation.build();
            this.default_map.add_reg(this.fuse_mldsa_revocation, 'h344);
            this.fuse_soc_stepping_id = new("fuse_soc_stepping_id");
            this.fuse_soc_stepping_id.configure(this);

            this.fuse_soc_stepping_id.build();
            this.default_map.add_reg(this.fuse_soc_stepping_id, 'h348);
            foreach(this.fuse_manuf_dbg_unlock_token[i0]) begin
                this.fuse_manuf_dbg_unlock_token[i0] = new($sformatf("fuse_manuf_dbg_unlock_token[%0d]", i0));
                this.fuse_manuf_dbg_unlock_token[i0].configure(this);
                
                this.fuse_manuf_dbg_unlock_token[i0].build();
                this.default_map.add_reg(this.fuse_manuf_dbg_unlock_token[i0], 'h34c + i0*'h4);
            end
            this.SS_CALIPTRA_BASE_ADDR_L = new("SS_CALIPTRA_BASE_ADDR_L");
            this.SS_CALIPTRA_BASE_ADDR_L.configure(this);

            this.SS_CALIPTRA_BASE_ADDR_L.build();
            this.default_map.add_reg(this.SS_CALIPTRA_BASE_ADDR_L, 'h500);
            this.SS_CALIPTRA_BASE_ADDR_H = new("SS_CALIPTRA_BASE_ADDR_H");
            this.SS_CALIPTRA_BASE_ADDR_H.configure(this);

            this.SS_CALIPTRA_BASE_ADDR_H.build();
            this.default_map.add_reg(this.SS_CALIPTRA_BASE_ADDR_H, 'h504);
            this.SS_MCI_BASE_ADDR_L = new("SS_MCI_BASE_ADDR_L");
            this.SS_MCI_BASE_ADDR_L.configure(this);

            this.SS_MCI_BASE_ADDR_L.build();
            this.default_map.add_reg(this.SS_MCI_BASE_ADDR_L, 'h508);
            this.SS_MCI_BASE_ADDR_H = new("SS_MCI_BASE_ADDR_H");
            this.SS_MCI_BASE_ADDR_H.configure(this);

            this.SS_MCI_BASE_ADDR_H.build();
            this.default_map.add_reg(this.SS_MCI_BASE_ADDR_H, 'h50c);
            this.SS_RECOVERY_IFC_BASE_ADDR_L = new("SS_RECOVERY_IFC_BASE_ADDR_L");
            this.SS_RECOVERY_IFC_BASE_ADDR_L.configure(this);

            this.SS_RECOVERY_IFC_BASE_ADDR_L.build();
            this.default_map.add_reg(this.SS_RECOVERY_IFC_BASE_ADDR_L, 'h510);
            this.SS_RECOVERY_IFC_BASE_ADDR_H = new("SS_RECOVERY_IFC_BASE_ADDR_H");
            this.SS_RECOVERY_IFC_BASE_ADDR_H.configure(this);

            this.SS_RECOVERY_IFC_BASE_ADDR_H.build();
            this.default_map.add_reg(this.SS_RECOVERY_IFC_BASE_ADDR_H, 'h514);
            this.SS_OTP_FC_BASE_ADDR_L = new("SS_OTP_FC_BASE_ADDR_L");
            this.SS_OTP_FC_BASE_ADDR_L.configure(this);

            this.SS_OTP_FC_BASE_ADDR_L.build();
            this.default_map.add_reg(this.SS_OTP_FC_BASE_ADDR_L, 'h518);
            this.SS_OTP_FC_BASE_ADDR_H = new("SS_OTP_FC_BASE_ADDR_H");
            this.SS_OTP_FC_BASE_ADDR_H.configure(this);

            this.SS_OTP_FC_BASE_ADDR_H.build();
            this.default_map.add_reg(this.SS_OTP_FC_BASE_ADDR_H, 'h51c);
            this.SS_UDS_SEED_BASE_ADDR_L = new("SS_UDS_SEED_BASE_ADDR_L");
            this.SS_UDS_SEED_BASE_ADDR_L.configure(this);

            this.SS_UDS_SEED_BASE_ADDR_L.build();
            this.default_map.add_reg(this.SS_UDS_SEED_BASE_ADDR_L, 'h520);
            this.SS_UDS_SEED_BASE_ADDR_H = new("SS_UDS_SEED_BASE_ADDR_H");
            this.SS_UDS_SEED_BASE_ADDR_H.configure(this);

            this.SS_UDS_SEED_BASE_ADDR_H.build();
            this.default_map.add_reg(this.SS_UDS_SEED_BASE_ADDR_H, 'h524);
            this.SS_PROD_DEBUG_UNLOCK_AUTH_PK_HASH_REG_BANK_OFFSET = new("SS_PROD_DEBUG_UNLOCK_AUTH_PK_HASH_REG_BANK_OFFSET");
            this.SS_PROD_DEBUG_UNLOCK_AUTH_PK_HASH_REG_BANK_OFFSET.configure(this);

            this.SS_PROD_DEBUG_UNLOCK_AUTH_PK_HASH_REG_BANK_OFFSET.build();
            this.default_map.add_reg(this.SS_PROD_DEBUG_UNLOCK_AUTH_PK_HASH_REG_BANK_OFFSET, 'h528);
            this.SS_NUM_OF_PROD_DEBUG_UNLOCK_AUTH_PK_HASHES = new("SS_NUM_OF_PROD_DEBUG_UNLOCK_AUTH_PK_HASHES");
            this.SS_NUM_OF_PROD_DEBUG_UNLOCK_AUTH_PK_HASHES.configure(this);

            this.SS_NUM_OF_PROD_DEBUG_UNLOCK_AUTH_PK_HASHES.build();
            this.default_map.add_reg(this.SS_NUM_OF_PROD_DEBUG_UNLOCK_AUTH_PK_HASHES, 'h52c);
            this.SS_DEBUG_INTENT = new("SS_DEBUG_INTENT");
            this.SS_DEBUG_INTENT.configure(this);

            this.SS_DEBUG_INTENT.build();
            this.default_map.add_reg(this.SS_DEBUG_INTENT, 'h530);
            foreach(this.SS_STRAP_GENERIC[i0]) begin
                this.SS_STRAP_GENERIC[i0] = new($sformatf("SS_STRAP_GENERIC[%0d]", i0));
                this.SS_STRAP_GENERIC[i0].configure(this);
                
                this.SS_STRAP_GENERIC[i0].build();
                this.default_map.add_reg(this.SS_STRAP_GENERIC[i0], 'h5a0 + i0*'h4);
            end
            this.SS_DBG_MANUF_SERVICE_REG_REQ = new("SS_DBG_MANUF_SERVICE_REG_REQ");
            this.SS_DBG_MANUF_SERVICE_REG_REQ.configure(this);

            this.SS_DBG_MANUF_SERVICE_REG_REQ.build();
            this.default_map.add_reg(this.SS_DBG_MANUF_SERVICE_REG_REQ, 'h5c0);
            this.SS_DBG_MANUF_SERVICE_REG_RSP = new("SS_DBG_MANUF_SERVICE_REG_RSP");
            this.SS_DBG_MANUF_SERVICE_REG_RSP.configure(this);

            this.SS_DBG_MANUF_SERVICE_REG_RSP.build();
            this.default_map.add_reg(this.SS_DBG_MANUF_SERVICE_REG_RSP, 'h5c4);
            foreach(this.SS_SOC_DBG_UNLOCK_LEVEL[i0]) begin
                this.SS_SOC_DBG_UNLOCK_LEVEL[i0] = new($sformatf("SS_SOC_DBG_UNLOCK_LEVEL[%0d]", i0));
                this.SS_SOC_DBG_UNLOCK_LEVEL[i0].configure(this);
                
                this.SS_SOC_DBG_UNLOCK_LEVEL[i0].build();
                this.default_map.add_reg(this.SS_SOC_DBG_UNLOCK_LEVEL[i0], 'h5c8 + i0*'h4);
            end
            foreach(this.SS_GENERIC_FW_EXEC_CTRL[i0]) begin
                this.SS_GENERIC_FW_EXEC_CTRL[i0] = new($sformatf("SS_GENERIC_FW_EXEC_CTRL[%0d]", i0));
                this.SS_GENERIC_FW_EXEC_CTRL[i0].configure(this);
                
                this.SS_GENERIC_FW_EXEC_CTRL[i0].build();
                this.default_map.add_reg(this.SS_GENERIC_FW_EXEC_CTRL[i0], 'h5d0 + i0*'h4);
            end
            foreach(this.internal_obf_key[i0]) begin
                this.internal_obf_key[i0] = new($sformatf("internal_obf_key[%0d]", i0));
                this.internal_obf_key[i0].configure(this);
                
                this.internal_obf_key[i0].build();
                this.default_map.add_reg(this.internal_obf_key[i0], 'h600 + i0*'h4);
            end
            this.internal_iccm_lock = new("internal_iccm_lock");
            this.internal_iccm_lock.configure(this);

            this.internal_iccm_lock.build();
            this.default_map.add_reg(this.internal_iccm_lock, 'h620);
            this.internal_fw_update_reset = new("internal_fw_update_reset");
            this.internal_fw_update_reset.configure(this);

            this.internal_fw_update_reset.build();
            this.default_map.add_reg(this.internal_fw_update_reset, 'h624);
            this.internal_fw_update_reset_wait_cycles = new("internal_fw_update_reset_wait_cycles");
            this.internal_fw_update_reset_wait_cycles.configure(this);

            this.internal_fw_update_reset_wait_cycles.build();
            this.default_map.add_reg(this.internal_fw_update_reset_wait_cycles, 'h628);
            this.internal_nmi_vector = new("internal_nmi_vector");
            this.internal_nmi_vector.configure(this);

            this.internal_nmi_vector.build();
            this.default_map.add_reg(this.internal_nmi_vector, 'h62c);
            this.internal_hw_error_fatal_mask = new("internal_hw_error_fatal_mask");
            this.internal_hw_error_fatal_mask.configure(this);

            this.internal_hw_error_fatal_mask.build();
            this.default_map.add_reg(this.internal_hw_error_fatal_mask, 'h630);
            this.internal_hw_error_non_fatal_mask = new("internal_hw_error_non_fatal_mask");
            this.internal_hw_error_non_fatal_mask.configure(this);

            this.internal_hw_error_non_fatal_mask.build();
            this.default_map.add_reg(this.internal_hw_error_non_fatal_mask, 'h634);
            this.internal_fw_error_fatal_mask = new("internal_fw_error_fatal_mask");
            this.internal_fw_error_fatal_mask.configure(this);

            this.internal_fw_error_fatal_mask.build();
            this.default_map.add_reg(this.internal_fw_error_fatal_mask, 'h638);
            this.internal_fw_error_non_fatal_mask = new("internal_fw_error_non_fatal_mask");
            this.internal_fw_error_non_fatal_mask.configure(this);

            this.internal_fw_error_non_fatal_mask.build();
            this.default_map.add_reg(this.internal_fw_error_non_fatal_mask, 'h63c);
            this.internal_rv_mtime_l = new("internal_rv_mtime_l");
            this.internal_rv_mtime_l.configure(this);

            this.internal_rv_mtime_l.build();
            this.default_map.add_reg(this.internal_rv_mtime_l, 'h640);
            this.internal_rv_mtime_h = new("internal_rv_mtime_h");
            this.internal_rv_mtime_h.configure(this);

            this.internal_rv_mtime_h.build();
            this.default_map.add_reg(this.internal_rv_mtime_h, 'h644);
            this.internal_rv_mtimecmp_l = new("internal_rv_mtimecmp_l");
            this.internal_rv_mtimecmp_l.configure(this);

            this.internal_rv_mtimecmp_l.build();
            this.default_map.add_reg(this.internal_rv_mtimecmp_l, 'h648);
            this.internal_rv_mtimecmp_h = new("internal_rv_mtimecmp_h");
            this.internal_rv_mtimecmp_h.configure(this);

            this.internal_rv_mtimecmp_h.build();
            this.default_map.add_reg(this.internal_rv_mtimecmp_h, 'h64c);
            this.intr_block_rf = new("intr_block_rf");
            this.intr_block_rf.configure(this);
            this.intr_block_rf.build();
            this.default_map.add_submap(this.intr_block_rf.default_map, 'h800);
        endfunction : build
    endclass : soc_ifc_reg

    `include "soc_ifc_reg_sample.svh"
endpackage: soc_ifc_reg_uvm
