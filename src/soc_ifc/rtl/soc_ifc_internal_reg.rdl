// SPDX-License-Identifier: Apache-2.0
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

////////////////////////////////////////////////////////////////
// Caliptra Internal Registers
reg {
    name = "De-Obfuscation Key";
    desc = "Stored De-Obfuscation key, not accessible by software.
            [br]Caliptra Access: -
            [br]SOC Access:      -";
    key key[32];
} internal_obf_key[8] @0x600;

reg {
    name = "ICCM Lock";
    desc = "Lock feature gates writes to the ICCM. When lock is set to
            1, writes are blocked. When cleared to 0, writes allowed.
            Write-once, meaning only a reset can clear it once set to 1.
            [br]Caliptra Access: RW1
            [br]SOC Access:      RO";

    field {desc="Lock bit gates writes to ICCM. Write 1 to set - cannot be cleared by SW."; hw=r; hwclr=true; sw=rw; onwrite=woset; precedence=hw; swwel=soc_req;} lock = 1'b0;
} internal_iccm_lock;

reg {
    name = "FW Update Reset";
    desc = "Control register to assert FW update reset. When cleared to
            0, no reset is triggered. When set to 1, uc-only reset is asserted.
            Field automatically clears 1 cycle after being set.
            [br]Caliptra Access: RW
            [br]SOC Access:      RO";

    field {desc = "FW Update reset to reset core"; hw = r; sw = rw; singlepulse=true; swwel = soc_req; resetsignal = cptra_rst_b;} core_rst = 1'b0;
} internal_fw_update_reset;

reg {
    name = "FW Update Reset Wait Cycles";
    desc = "Control register to set the number of cycles for which FW update reset must be asserted. Default is 5. Max value is 255 (8 bit).
            [br]Caliptra Access: RW
            [br]SOC Access:      RO";

    field {desc = "FW Update reset wait cycles"; hw = r; sw = rw; swwel = soc_req; resetsignal = cptra_rst_b;} wait_cycles[8] = 8'h5;
} internal_fw_update_reset_wait_cycles;

reg {
    name = "NMI Vector";
    desc = "32-bit register providing the jump vector for RISC-V to transition for NMI handling code.
            Default is the base address of ROM, but may be updated for enhanced handling by runtime images.
            Bit [0] is ignored to enforce half-word alignment of address.
            [br]Caliptra Access: RW
            [br]SOC Access:      RO";

    field {desc = "NMI Vector"; hw = r; sw = rw; swwel = soc_req; resetsignal = cptra_rst_b;} vec[32] = 32'h0;
} internal_nmi_vector;

reg {
    name = "Hardware Error Fatal Mask";
    desc = "Bit mask for the register CPTRA_HW_ERROR_FATAL to determine
            which bits are disabled for interrupt generation on the
            cptra_error_fatal output signal.
            A value of 1 in a field of this register means the corresponding bit
            position in CPTRA_HW_ERROR_FATAL will not produce an interrupt
            output assertion.
            [br]Caliptra Access: RW
            [br]SOC Access:      RO";
    rw_ro_hw mask_iccm_ecc_unc=0;     /* Uncorrectable double-bit error in ICCM */
    rw_ro_hw mask_dccm_ecc_unc=0;     /* Uncorrectable double-bit error in DCCM */
    rw_ro_hw mask_nmi_pin=0;          /* Non-Maskable Interrupt due to WDT timeout */
} internal_hw_error_fatal_mask;
reg {
    name = "Hardware Error Non-Fatal Mask";
    desc = "Bit mask for the register CPTRA_HW_ERROR_NON_FATAL to determine
            which bits are disabled for interrupt generation on the
            cptra_error_non_fatal output signal.
            A value of 1 in a field of this register means the corresponding bit
            position in CPTRA_HW_ERROR_NON_FATAL will not produce an interrupt
            output assertion.
            [br]Caliptra Access: RW
            [br]SOC Access:      RO";
    rw_ro_hw mask_mbox_prot_no_lock=0; /* SOC access while not locked */
    rw_ro_hw mask_mbox_prot_ooo=0;     /* Register access out-of-order */
    rw_ro_hw mask_mbox_ecc_unc=0;      /* Uncorrectable double-bit error in DCCM */
} internal_hw_error_non_fatal_mask;
reg {
    name = "Firmware Error Fatal Mask";
    desc = "Bit mask for the register CPTRA_FW_ERROR_FATAL to determine
            which bits are disabled for interrupt generation on the
            cptra_error_fatal output signal.
            A value of 1 in a field of this register means the corresponding bit
            position in CPTRA_FW_ERROR_FATAL will not produce an interrupt
            output assertion.
            [br]Caliptra Access: RW
            [br]SOC Access:      RO";
    rw_ro_hw mask[32]=0; 
} internal_fw_error_fatal_mask;
reg {
    name = "Firmware Error Non-Fatal Mask";
    desc = "Bit mask for the register CPTRA_FW_ERROR_NON_FATAL to determine
            which bits are disabled for interrupt generation on the
            cptra_error_non_fatal output signal.
            A value of 1 in a field of this register means the corresponding bit
            position in CPTRA_FW_ERROR_NON_FATAL will not produce an interrupt
            output assertion.
            [br]Caliptra Access: RW
            [br]SOC Access:      RO";
    rw_ro_hw mask[32]=0; 
} internal_fw_error_non_fatal_mask;

reg {
    name = "mtime low";
    desc = "RISC-V Standard Machine-mode Time Counter, lower 32-bits.
            [br]Frequency of counter is indicated in CPTRA_TIMER_CONFIG.clk_period.
            [br]Caliptra Access: RW
            [br]SOC Access:      RO";
    field {desc = "Counter Low" ; sw = rw; precedence = sw; swmod = true; hw = r; swwel = soc_req; counter = true; incrvalue = 1; overflow = true; resetsignal = cptra_pwrgood;} count_l[32] = 32'h0;
} internal_rv_mtime_l;

reg {
    name = "mtime high";
    desc = "RISC-V Standard Machine-mode Time Counter, upper 32-bits.
            [br]Frequency of counter is indicated in CPTRA_TIMER_CONFIG.clk_period.
            [br]Caliptra Access: RW
            [br]SOC Access:      RO";
    field {desc = "Counter High"; sw = rw; precedence = sw; swmod = true; hw = r; swwel = soc_req; counter = true; incrvalue = 1;                  resetsignal = cptra_pwrgood;} count_h[32] = 32'h0;
} internal_rv_mtime_h;

reg {
    name = "mtimecmp low";
    desc = "RISC-V Standard Machine-mode Time Counter Compare Value, lower 32-bits.
            [br]Caliptra Access: RW
            [br]SOC Access:      RO";
    field {desc = "Count Compare Low" ; sw = rw; hw = r; swwel = soc_req; resetsignal = cptra_pwrgood;} compare_l[32] = 32'h0;
} internal_rv_mtimecmp_l;

reg {
    name = "mtimecmp high";
    desc = "RISC-V Standard Machine-mode Time Counter Compare Value, upper 32-bits.
            [br]Caliptra Access: RW
            [br]SOC Access:      RO";
    field {desc = "Count Compare High"; sw = rw; hw = r; swwel = soc_req; resetsignal = cptra_pwrgood;} compare_h[32] = 32'h0;
} internal_rv_mtimecmp_h;


////////////////////////////////////////////////////////////////
// Interrupts
/* -----------------------
 * Register File definitive definition
 * ----------------------- */

// Notifications are non-error events that occur during normal operation of the module.
// E.g. a completion of a job may produce a notification.
// Error and notification events are separated into separate status/trigger registers
// to allow effective priority allocation by software
regfile intr_block_t {


    /* -----------------------
     * Default properties for Register File
     * ----------------------- */

    name = "Interrupt Register Block";
    desc = "Set of registers to implement interrupt functionality
            for soc interface.
            All registers have the following access privileges:
            [br]Caliptra Access: RW
            [br]SOC Access:      RO";

    default regwidth = 32; // reg property
    default accesswidth = 32; // reg property
    default hw = na; // field property
    default swwel = soc_req; // Used in MBOX interrupt registers to avoid SoC write priv.


    /* -----------------------
     * Register definitive definitions
     * ----------------------- */

    /* ---- Global Interrupt Enable ---- */
    reg global_intr_en_t {
        name = "Per-Type Interrupt Enable Register";
        desc = "Dedicated register with one bit for each event type that may produce an interrupt.";

        default hw = na;
        default sw = rw;

        // Global enablement (for interrupts of the event types defined for this module)
        field {desc = "Global enable bit for all events of type 'Error'";       } error_en = 1'b0;
        field {desc = "Global enable bit for all events of type 'Notification'";} notif_en = 1'b0;
    };

    /* ---- Error Interrupt Enable ---- */
    reg error_intr_en_t {
        name = "Per-Event Interrupt Enable Register";
        desc = "Dedicated register with one bit for each event that may produce an interrupt.";

        default hw = na;
        default sw = rw;

        // Specific enables for the events defined in this
        // event type in the instantiating peripheral.
        field {desc = "Enable bit for Internal Errors";                                                            } error_internal_en = 1'b0;
        field {desc = "Enable bit for Invalid Device in Pauser field";                                             } error_inv_dev_en  = 1'b0;
        field {desc = "Enable bit for Failed Commands (invalid protocol or FW Fail Status)";                       } error_cmd_fail_en = 1'b0;
        field {desc = "Enable bit for Bad Fuse received from SoC";                                                 } error_bad_fuse_en = 1'b0;
        field {desc = "Enable bit for ICCM access blocked by lock";                                                } error_iccm_blocked_en = 1'b0;
        field {desc = "Enable bit for Mailbox ECC Double-bit Error (uncorrectable)";                               } error_mbox_ecc_unc_en = 1'b0;
        field {desc = "Enable bit for WDT Timer1 timeout";                                                         } error_wdt_timer1_timeout_en = 1'b0;
        field {desc = "Enable bit for WDT Timer2 timeout, applicable if timer2 is enabled as an independent timer";} error_wdt_timer2_timeout_en = 1'b0;
    };

    /* ---- Notification Interrupt Enable ---- */
    reg notif_intr_en_t {
        name = "Per-Event Interrupt Enable Register";
        desc = "Dedicated register with one bit for each event that may produce an interrupt.";

        default hw = na;
        default sw = rw;

        // Specific enables for the events defined in this
        // event type in the instantiating peripheral.
        field {desc = "Enable bit for Command Available";                         } notif_cmd_avail_en = 1'b0;
        field {desc = "Enable bit for Mailbox ECC Single-bit Error (correctable)";} notif_mbox_ecc_cor_en = 1'b0;
        field {desc = "Enable bit for Security State, Debug Locked transition";   } notif_debug_locked_en = 1'b0;
        field {desc = "Enable bit for Scan mode";                                 } notif_scan_mode_en = 1'b0;
        field {desc = "Enable bit for SoC requested the mailbox while locked";    } notif_soc_req_lock_en = 1'b0;
        field {desc = "Enable bit for Generic Input Wires Toggle";                } notif_gen_in_toggle_en = 1'b0;
    };

    /* ---- Error Interrupt Status ---- */
    reg error_intr_t {
        name = "Interrupt Status Register type definition";
        desc = "Single bit indicating occurrence of each interrupt event.
                Sticky, level assertion, write-1-to-clear.";

        default precedence = hw;
        default hw = w;
        default hwset = true;
        default sw = rw;
        default woclr = true;
        default level intr;

        field {desc = "Internal Errors status bit";                                      } error_internal_sts = 1'b0;
        field {desc = "Invalid Device in Pauser field status bit";                       } error_inv_dev_sts = 1'b0;
        field {desc = "Failed Commands status bit (invalid protocol or FW Fail Status)"; } error_cmd_fail_sts = 1'b0;
        field {desc = "Bad Fuse received from SoC status bit";                           } error_bad_fuse_sts = 1'b0;
        field {desc = "ICCM access blocked by lock status bit";                          } error_iccm_blocked_sts = 1'b0;
        field {desc = "Mailbox ECC Double-bit Error (uncorrectable) status bit";         } error_mbox_ecc_unc_sts = 1'b0;
        field {desc = "WDT Timer1 timeout status bit";                                   } error_wdt_timer1_timeout_sts = 1'b0;
        field {desc = "WDT Timer2 timeout status bit";                                   } error_wdt_timer2_timeout_sts = 1'b0;
    };

    /* ---- Notification Interrupt Status ---- */
    reg notif_intr_t {
        name = "Interrupt Status Register type definition";
        desc = "Single bit indicating occurrence of each interrupt event.
                Sticky, level assertion, write-1-to-clear.";

        default precedence = hw;
        default hw = w;
        default hwset = true;
        default sw = rw;
        default woclr = true;
        default level intr;

        field {desc = "Command Available status bit";                         } notif_cmd_avail_sts = 1'b0;
        field {desc = "Mailbox ECC Single-bit Error (correctable) status bit";} notif_mbox_ecc_cor_sts = 1'b0;
        field {desc = "Security State, Debug Locked transition status bit";   } notif_debug_locked_sts = 1'b0;
        field {desc = "Scan mode status bit";                                 } notif_scan_mode_sts = 1'b0;
        field {desc = "SoC requested the mailbox while locked status bit";    } notif_soc_req_lock_sts = 1'b0;
        field {desc = "Generic Input Wires Toggle status bit";                } notif_gen_in_toggle_sts = 1'b0;
    };

    /* ---- Aggregated Interrupt Status ---- */
    reg global_intr_t {
        name = "Interrupt Status Aggregation Register type definition";
        desc = "Single bit indicating occurrence of any interrupt event
                of a given type. E.g. Notifications and Errors may drive
                to two separate interrupt registers. There may be
                multiple sources of Notifications or Errors that are
                aggregated into a single interrupt pin for that
                respective type. That pin feeds through this register
                in order to apply a global enablement of that interrupt
                event type.
                Nonsticky assertion.";

        default hw = w;
        default sw = r;
        default nonsticky intr;

        field {desc = "Interrupt Event Aggregation status bit"; swwel = false;} agg_sts = 1'b0;
    };

    /* ---- Error Interrupt Trigger ---- */
    reg error_intr_trig_t {
        name = "Interrupt Trigger Register type definition";
        desc = "Single bit for each interrupt event allows SW to manually
                trigger occurrence of that event. Upon SW write, the bit
                will pulse for 1 cycle then clear to 0.";

        default hw = na;
        default sw = rw;
        default woset = true;
        default singlepulse = true;

        // Instantiate triggers bit-by-bit.
        field {desc = "Internal Errors trigger bit";                             } error_internal_trig = 1'b0;
        field {desc = "Invalid Device in Pauser field trigger bit";              } error_inv_dev_trig  = 1'b0;
        field {desc = "Failed Commands trigger bit";                             } error_cmd_fail_trig = 1'b0;
        field {desc = "Bad Fuse received from SoC trigger bit";                  } error_bad_fuse_trig = 1'b0;
        field {desc = "ICCM access blocked by lock trigger bit";                 } error_iccm_blocked_trig = 1'b0;
        field {desc = "Mailbox ECC Double-bit Error (uncorrectable) trigger bit";} error_mbox_ecc_unc_trig = 1'b0;
        field {desc = "WDT Timer1 timeout trigger bit";                          } error_wdt_timer1_timeout_trig = 1'b0;
        field {desc = "WDT Timer2 timeout trigger bit";                          } error_wdt_timer2_timeout_trig = 1'b0;
    };

    /* ---- Notification Interrupt Trigger ---- */
    reg notif_intr_trig_t {
        name = "Interrupt Trigger Register type definition";
        desc = "Single bit for each interrupt event allows SW to manually
                trigger occurrence of that event. Upon SW write, the bit
                will pulse for 1 cycle then clear to 0.";

        default hw = na;
        default sw = rw;
        default woset = true;
        default singlepulse = true;

        // Instantiate triggers bit-by-bit.
        field {desc = "Command Available trigger bit";                         } notif_cmd_avail_trig = 1'b0;
        field {desc = "Mailbox ECC Single-bit Error (correctable) trigger bit";} notif_mbox_ecc_cor_trig = 1'b0;
        field {desc = "Security State, Debug Locked transition trigger bit";   } notif_debug_locked_trig = 1'b0;
        field {desc = "Scan mode trigger bit";                                 } notif_scan_mode_trig = 1'b0;
        field {desc = "SoC requested the mailbox while locked trigger bit";    } notif_soc_req_lock_trig = 1'b0;
        field {desc = "Generic Input Wires Toggle trigger bit";                } notif_gen_in_toggle_trig = 1'b0;
    };

    /* ---- Interrupt Statistics Counter Incrementor ---- */
    reg intr_count_incr_t {
        name = "Interrupt Event Count Incrementor";
        desc = "Trigger the event counter to increment based on observing
                the rising edge of an interrupt event input from the
                Hardware. The same input signal that causes an interrupt
                event to be set (sticky) also causes this signal to pulse
                for 1 clock cycle, resulting in the event counter
                incrementing by 1 for every interrupt event.
                This is implemented as a down-counter (1-bit) that will
                decrement immediately on being set - resulting in a pulse";

        default hw = w;
        default sw = r; // Has to have some access.... ideally SW wouldn't even see this
        default hwset = true;
        default decrvalue = 1;
        default counter;

        field {desc = "Pulse mirrors interrupt event occurrence"; swwel = false;} pulse = 1'b0;
    };

    /* ---- Interrupt Statistics Counter ---- */
    reg intr_count_t {
        name = "Interrupt Event Counter";
        desc = "Provides statistics about the number of events that have
                occurred.
                Will not overflow ('incrsaturate').";

        default sw = rw;
        default hw = na;
        default incrvalue = 1;
        default incrsaturate = true;
        default counter;

        field {desc = "Count field";} cnt[32] = 32'h0;
    };


    /* ------------------------------------------------- Registers ------------------------------------------------- */
    // First 9 registers are static and always defined                                                               //
    global_intr_en_t  global_intr_en_r;      /* 1-bit per event type */                                              //
    error_intr_en_t   error_intr_en_r;       /* 1-bit per error */                                                   //
    notif_intr_en_t   notif_intr_en_r;       /* 1-bit per notification */                                            //
    global_intr_t     error_global_intr_r;   /* 1-bit aggregating all error interrupts with global enable */         //
    global_intr_t     notif_global_intr_r;   /* 1-bit aggregating all notification interrupts with global enable */  //
    error_intr_t      error_internal_intr_r; /* Error pending, SW write 1 to clear */                                //
    notif_intr_t      notif_internal_intr_r; /* Notification pending, SW write 1 to clear */                         //
    error_intr_trig_t error_intr_trig_r;     /* SW sets error bit for interrupt testing */                           //
    notif_intr_trig_t notif_intr_trig_r;     /* SW sets notification bit for interrupt testing */                    //
                                                                                                                     //
    // Align this set of registers; number of counters is based on peripheral event requirements                     //
    intr_count_t      error_internal_intr_count_r @0x100;  /* Per error */                                           //
    intr_count_t      error_inv_dev_intr_count_r;          /* Per error */                                           //
    intr_count_t      error_cmd_fail_intr_count_r;         /* Per error */                                           //
    intr_count_t      error_bad_fuse_intr_count_r;         /* Per error */                                           //
    intr_count_t      error_iccm_blocked_intr_count_r;     /* Per error */                                           //
    intr_count_t      error_mbox_ecc_unc_intr_count_r;     /* Per error */                                           //
    intr_count_t      error_wdt_timer1_timeout_intr_count_r; /* Per error */                                         //
    intr_count_t      error_wdt_timer2_timeout_intr_count_r; /* Per error */                                         //
    intr_count_t      notif_cmd_avail_intr_count_r @0x180; /* Per notification */                                    //
    intr_count_t      notif_mbox_ecc_cor_intr_count_r;     /* Per notification */                                    //
    intr_count_t      notif_debug_locked_intr_count_r;     /* Per notification */                                    //
    intr_count_t      notif_scan_mode_intr_count_r;        /* Per notification */                                    //
    intr_count_t      notif_soc_req_lock_intr_count_r;     /* Per notification */                                    //
    intr_count_t      notif_gen_in_toggle_intr_count_r;    /* Per notification */                                    //
                                                                                                                     //
    // These registers should be treated by SW as reserved, and ignored.                                             //
    // Offset at 0x200 gives enough space for 32 Errors and 32 Notifications                                         //
    // to be implemented (requiring 2*32 32-bit registers starting at                                                //
    // offset 0x100), and still allowing the entire regfile to fit                                                   //
    // inside a 1024-byte space.                                                                                     //
    intr_count_incr_t error_internal_intr_count_incr_r @0x200; /* Per error count incrementor pulse */               //
    intr_count_incr_t error_inv_dev_intr_count_incr_r;         /* Per error count incrementor pulse */               //
    intr_count_incr_t error_cmd_fail_intr_count_incr_r;        /* Per error count incrementor pulse */               //
    intr_count_incr_t error_bad_fuse_intr_count_incr_r;        /* Per error count incrementor pulse */               //
    intr_count_incr_t error_iccm_blocked_intr_count_incr_r;    /* Per error count incrementor pulse */               //
    intr_count_incr_t error_mbox_ecc_unc_intr_count_incr_r;    /* Per error count incrementor pulse */               //
    intr_count_incr_t error_wdt_timer1_timeout_intr_count_incr_r; /* Per error count incrementor pulse */            //
    intr_count_incr_t error_wdt_timer2_timeout_intr_count_incr_r; /* Per error count incrementor pulse */            //
    intr_count_incr_t notif_cmd_avail_intr_count_incr_r;       /* Per notification count incrementor pulse */        //
    intr_count_incr_t notif_mbox_ecc_cor_intr_count_incr_r;    /* Per notification count incrementor pulse */        //
    intr_count_incr_t notif_debug_locked_intr_count_incr_r;    /* Per notification count incrementor pulse */        //
    intr_count_incr_t notif_scan_mode_intr_count_incr_r;       /* Per notification count incrementor pulse */        //
    intr_count_incr_t notif_soc_req_lock_intr_count_incr_r;    /* Per notification count incrementor pulse */        //
    intr_count_incr_t notif_gen_in_toggle_intr_count_incr_r;   /* Per notification count incrementor pulse */        //
    /* ------------------------------------------------------------------------------------------------------------- */

    /* ---- Reset assignment for Error Events ---- */
    error_internal_intr_r.error_internal_sts     -> resetsignal = cptra_pwrgood;
    error_internal_intr_r.error_inv_dev_sts      -> resetsignal = cptra_pwrgood;
    error_internal_intr_r.error_cmd_fail_sts     -> resetsignal = cptra_pwrgood;
    error_internal_intr_r.error_bad_fuse_sts     -> resetsignal = cptra_pwrgood;
    error_internal_intr_r.error_iccm_blocked_sts -> resetsignal = cptra_pwrgood;
    error_internal_intr_r.error_mbox_ecc_unc_sts -> resetsignal = cptra_pwrgood;
    error_internal_intr_r.error_wdt_timer1_timeout_sts -> resetsignal = cptra_pwrgood;
    error_internal_intr_r.error_wdt_timer2_timeout_sts -> resetsignal = cptra_pwrgood;
    error_internal_intr_count_r.cnt          -> resetsignal = cptra_pwrgood;
    error_inv_dev_intr_count_r.cnt           -> resetsignal = cptra_pwrgood;
    error_cmd_fail_intr_count_r.cnt          -> resetsignal = cptra_pwrgood;
    error_bad_fuse_intr_count_r.cnt          -> resetsignal = cptra_pwrgood;
    error_iccm_blocked_intr_count_r.cnt      -> resetsignal = cptra_pwrgood;
    error_mbox_ecc_unc_intr_count_r.cnt      -> resetsignal = cptra_pwrgood;
    error_wdt_timer1_timeout_intr_count_r.cnt -> resetsignal = cptra_pwrgood;
    error_wdt_timer2_timeout_intr_count_r.cnt -> resetsignal = cptra_pwrgood;
    // TODO: Use this same reset for the error incrementor pulse too?

    /* ---- Interrupt Event Dynamic Assignments ---- */
    error_internal_intr_r.error_internal_sts     -> enable = error_intr_en_r.error_internal_en;
    error_internal_intr_r.error_inv_dev_sts      -> enable = error_intr_en_r.error_inv_dev_en;
    error_internal_intr_r.error_cmd_fail_sts     -> enable = error_intr_en_r.error_cmd_fail_en;
    error_internal_intr_r.error_bad_fuse_sts     -> enable = error_intr_en_r.error_bad_fuse_en;
    error_internal_intr_r.error_iccm_blocked_sts -> enable = error_intr_en_r.error_iccm_blocked_en;
    error_internal_intr_r.error_mbox_ecc_unc_sts -> enable = error_intr_en_r.error_mbox_ecc_unc_en;
    error_internal_intr_r.error_wdt_timer1_timeout_sts -> enable = error_intr_en_r.error_wdt_timer1_timeout_en;
    error_internal_intr_r.error_wdt_timer2_timeout_sts -> enable = error_intr_en_r.error_wdt_timer2_timeout_en;
    notif_internal_intr_r.notif_cmd_avail_sts     -> enable = notif_intr_en_r.notif_cmd_avail_en;
    notif_internal_intr_r.notif_mbox_ecc_cor_sts  -> enable = notif_intr_en_r.notif_mbox_ecc_cor_en;
    notif_internal_intr_r.notif_debug_locked_sts  -> enable = notif_intr_en_r.notif_debug_locked_en;
    notif_internal_intr_r.notif_scan_mode_sts     -> enable = notif_intr_en_r.notif_scan_mode_en;
    notif_internal_intr_r.notif_soc_req_lock_sts  -> enable = notif_intr_en_r.notif_soc_req_lock_en;
    notif_internal_intr_r.notif_gen_in_toggle_sts -> enable = notif_intr_en_r.notif_gen_in_toggle_en;

    error_internal_intr_r.error_internal_sts     -> next   = error_intr_trig_r.error_internal_trig;
    error_internal_intr_r.error_inv_dev_sts      -> next   = error_intr_trig_r.error_inv_dev_trig;
    error_internal_intr_r.error_cmd_fail_sts     -> next   = error_intr_trig_r.error_cmd_fail_trig;
    error_internal_intr_r.error_bad_fuse_sts     -> next   = error_intr_trig_r.error_bad_fuse_trig;
    error_internal_intr_r.error_iccm_blocked_sts -> next   = error_intr_trig_r.error_iccm_blocked_trig;
    error_internal_intr_r.error_mbox_ecc_unc_sts -> next   = error_intr_trig_r.error_mbox_ecc_unc_trig;
    error_internal_intr_r.error_wdt_timer1_timeout_sts -> next   = error_intr_trig_r.error_wdt_timer1_timeout_trig;
    error_internal_intr_r.error_wdt_timer2_timeout_sts -> next   = error_intr_trig_r.error_wdt_timer2_timeout_trig;
    notif_internal_intr_r.notif_cmd_avail_sts     -> next   = notif_intr_trig_r.notif_cmd_avail_trig;
    notif_internal_intr_r.notif_mbox_ecc_cor_sts  -> next   = notif_intr_trig_r.notif_mbox_ecc_cor_trig;
    notif_internal_intr_r.notif_debug_locked_sts  -> next   = notif_intr_trig_r.notif_debug_locked_trig;
    notif_internal_intr_r.notif_scan_mode_sts     -> next   = notif_intr_trig_r.notif_scan_mode_trig;
    notif_internal_intr_r.notif_soc_req_lock_sts  -> next   = notif_intr_trig_r.notif_soc_req_lock_trig;
    notif_internal_intr_r.notif_gen_in_toggle_sts -> next   = notif_intr_trig_r.notif_gen_in_toggle_trig;

    // NOTE: hwset for events is implicitly defined as module input

    /* ---- Global Interrupt Dynamic Assignments ---- */
    error_global_intr_r.agg_sts -> enable = global_intr_en_r.error_en;
    notif_global_intr_r.agg_sts -> enable = global_intr_en_r.notif_en;

    error_global_intr_r.agg_sts -> next = error_internal_intr_r -> intr;
    notif_global_intr_r.agg_sts -> next = notif_internal_intr_r -> intr;

    /* ---- Event Statistics Tracker Assignments ---- */
    // NOTE: This method relies upon a "counter" that is set using the
    //       same events that trigger an interrupt, then immediately
    //       self-clearing, which results in a pulse. Must be configured
    //       to be sensitive to the interrupt trigger events for each event.
    //       The output pulse is then used to increment the ACTUAL counter
    error_internal_intr_count_incr_r.pulse -> hwset    = error_internal_intr_r.error_internal_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    error_internal_intr_count_incr_r.pulse -> next     = error_internal_intr_r.error_internal_sts -> next;  // /      as a pulse to increment the intr_count_r register
    error_internal_intr_count_incr_r.pulse -> we       = error_internal_intr_r.error_internal_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    error_internal_intr_count_incr_r.pulse -> decr     = error_internal_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    error_internal_intr_count_r.cnt        -> incr     = error_internal_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    error_inv_dev_intr_count_incr_r.pulse -> hwset    = error_internal_intr_r.error_inv_dev_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    error_inv_dev_intr_count_incr_r.pulse -> next     = error_internal_intr_r.error_inv_dev_sts -> next;  // /      as a pulse to increment the intr_count_r register
    error_inv_dev_intr_count_incr_r.pulse -> we       = error_internal_intr_r.error_inv_dev_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    error_inv_dev_intr_count_incr_r.pulse -> decr     = error_inv_dev_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    error_inv_dev_intr_count_r.cnt        -> incr     = error_inv_dev_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    error_cmd_fail_intr_count_incr_r.pulse -> hwset    = error_internal_intr_r.error_cmd_fail_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    error_cmd_fail_intr_count_incr_r.pulse -> next     = error_internal_intr_r.error_cmd_fail_sts -> next;  // /      as a pulse to increment the intr_count_r register
    error_cmd_fail_intr_count_incr_r.pulse -> we       = error_internal_intr_r.error_cmd_fail_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    error_cmd_fail_intr_count_incr_r.pulse -> decr     = error_cmd_fail_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    error_cmd_fail_intr_count_r.cnt        -> incr     = error_cmd_fail_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    error_bad_fuse_intr_count_incr_r.pulse -> hwset    = error_internal_intr_r.error_bad_fuse_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    error_bad_fuse_intr_count_incr_r.pulse -> next     = error_internal_intr_r.error_bad_fuse_sts -> next;  // /      as a pulse to increment the intr_count_r register
    error_bad_fuse_intr_count_incr_r.pulse -> we       = error_internal_intr_r.error_bad_fuse_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    error_bad_fuse_intr_count_incr_r.pulse -> decr     = error_bad_fuse_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    error_bad_fuse_intr_count_r.cnt        -> incr     = error_bad_fuse_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    error_iccm_blocked_intr_count_incr_r.pulse -> hwset    = error_internal_intr_r.error_iccm_blocked_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    error_iccm_blocked_intr_count_incr_r.pulse -> next     = error_internal_intr_r.error_iccm_blocked_sts -> next;  // /      as a pulse to increment the intr_count_r register
    error_iccm_blocked_intr_count_incr_r.pulse -> we       = error_internal_intr_r.error_iccm_blocked_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    error_iccm_blocked_intr_count_incr_r.pulse -> decr     = error_iccm_blocked_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    error_iccm_blocked_intr_count_r.cnt        -> incr     = error_iccm_blocked_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    error_mbox_ecc_unc_intr_count_incr_r.pulse -> hwset    = error_internal_intr_r.error_mbox_ecc_unc_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    error_mbox_ecc_unc_intr_count_incr_r.pulse -> next     = error_internal_intr_r.error_mbox_ecc_unc_sts -> next;  // /      as a pulse to increment the intr_count_r register
    error_mbox_ecc_unc_intr_count_incr_r.pulse -> we       = error_internal_intr_r.error_mbox_ecc_unc_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    error_mbox_ecc_unc_intr_count_incr_r.pulse -> decr     = error_mbox_ecc_unc_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    error_mbox_ecc_unc_intr_count_r.cnt        -> incr     = error_mbox_ecc_unc_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    error_wdt_timer1_timeout_intr_count_incr_r.pulse -> hwset    = error_internal_intr_r.error_wdt_timer1_timeout_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    error_wdt_timer1_timeout_intr_count_incr_r.pulse -> next     = error_internal_intr_r.error_wdt_timer1_timeout_sts -> next;  // /      as a pulse to increment the intr_count_r register
    error_wdt_timer1_timeout_intr_count_incr_r.pulse -> we       = error_internal_intr_r.error_wdt_timer1_timeout_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    error_wdt_timer1_timeout_intr_count_incr_r.pulse -> decr     = error_wdt_timer1_timeout_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    error_wdt_timer1_timeout_intr_count_r.cnt        -> incr     = error_wdt_timer1_timeout_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    error_wdt_timer2_timeout_intr_count_incr_r.pulse -> hwset    = error_internal_intr_r.error_wdt_timer2_timeout_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    error_wdt_timer2_timeout_intr_count_incr_r.pulse -> next     = error_internal_intr_r.error_wdt_timer2_timeout_sts -> next;  // /      as a pulse to increment the intr_count_r register
    error_wdt_timer2_timeout_intr_count_incr_r.pulse -> we       = error_internal_intr_r.error_wdt_timer2_timeout_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    error_wdt_timer2_timeout_intr_count_incr_r.pulse -> decr     = error_wdt_timer2_timeout_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    error_wdt_timer2_timeout_intr_count_r.cnt        -> incr     = error_wdt_timer2_timeout_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    notif_cmd_avail_intr_count_incr_r.pulse -> hwset    = notif_internal_intr_r.notif_cmd_avail_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    notif_cmd_avail_intr_count_incr_r.pulse -> next     = notif_internal_intr_r.notif_cmd_avail_sts -> next;  // /      as a pulse to increment the intr_count_r register
    notif_cmd_avail_intr_count_incr_r.pulse -> we       = notif_internal_intr_r.notif_cmd_avail_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    notif_cmd_avail_intr_count_incr_r.pulse -> decr     = notif_cmd_avail_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    notif_cmd_avail_intr_count_r.cnt        -> incr     = notif_cmd_avail_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    notif_mbox_ecc_cor_intr_count_incr_r.pulse -> hwset = notif_internal_intr_r.notif_mbox_ecc_cor_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    notif_mbox_ecc_cor_intr_count_incr_r.pulse -> next  = notif_internal_intr_r.notif_mbox_ecc_cor_sts -> next;  // /      as a pulse to increment the intr_count_r register
    notif_mbox_ecc_cor_intr_count_incr_r.pulse -> we    = notif_internal_intr_r.notif_mbox_ecc_cor_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    notif_mbox_ecc_cor_intr_count_incr_r.pulse -> decr  = notif_mbox_ecc_cor_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    notif_mbox_ecc_cor_intr_count_r.cnt        -> incr  = notif_mbox_ecc_cor_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    notif_debug_locked_intr_count_incr_r.pulse -> hwset = notif_internal_intr_r.notif_debug_locked_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    notif_debug_locked_intr_count_incr_r.pulse -> next  = notif_internal_intr_r.notif_debug_locked_sts -> next;  // /      as a pulse to increment the intr_count_r register
    notif_debug_locked_intr_count_incr_r.pulse -> we    = notif_internal_intr_r.notif_debug_locked_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    notif_debug_locked_intr_count_incr_r.pulse -> decr  = notif_debug_locked_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    notif_debug_locked_intr_count_r.cnt        -> incr  = notif_debug_locked_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    notif_scan_mode_intr_count_incr_r.pulse -> hwset = notif_internal_intr_r.notif_scan_mode_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    notif_scan_mode_intr_count_incr_r.pulse -> next  = notif_internal_intr_r.notif_scan_mode_sts -> next;  // /      as a pulse to increment the intr_count_r register
    notif_scan_mode_intr_count_incr_r.pulse -> we    = notif_internal_intr_r.notif_scan_mode_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    notif_scan_mode_intr_count_incr_r.pulse -> decr  = notif_scan_mode_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    notif_scan_mode_intr_count_r.cnt        -> incr  = notif_scan_mode_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    notif_soc_req_lock_intr_count_incr_r.pulse -> hwset = notif_internal_intr_r.notif_soc_req_lock_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    notif_soc_req_lock_intr_count_incr_r.pulse -> next  = notif_internal_intr_r.notif_soc_req_lock_sts -> next;  // /      as a pulse to increment the intr_count_r register
    notif_soc_req_lock_intr_count_incr_r.pulse -> we    = notif_internal_intr_r.notif_soc_req_lock_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    notif_soc_req_lock_intr_count_incr_r.pulse -> decr  = notif_soc_req_lock_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    notif_soc_req_lock_intr_count_r.cnt        -> incr  = notif_soc_req_lock_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    notif_gen_in_toggle_intr_count_incr_r.pulse -> hwset = notif_internal_intr_r.notif_gen_in_toggle_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    notif_gen_in_toggle_intr_count_incr_r.pulse -> next  = notif_internal_intr_r.notif_gen_in_toggle_sts -> next;  // /      as a pulse to increment the intr_count_r register
    notif_gen_in_toggle_intr_count_incr_r.pulse -> we    = notif_internal_intr_r.notif_gen_in_toggle_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    notif_gen_in_toggle_intr_count_incr_r.pulse -> decr  = notif_gen_in_toggle_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    notif_gen_in_toggle_intr_count_r.cnt        -> incr  = notif_gen_in_toggle_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit


};

/* -----------------------
 * Register File instance
 * ----------------------- */
intr_block_t intr_block_rf @0x800; // Offset to accommodate FUSES and allow space above for iDevID if needed
