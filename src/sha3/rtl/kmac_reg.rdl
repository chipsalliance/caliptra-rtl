addrmap kmac_reg {
    desc="address maps for SHAKE accelerator register space";
    addressing = compact;
    lsb0 = true; // lsb0 property is implicit/default. See docs for
                 // SystemRDL 2.0 sections 9.1 and 13.4

    default hw = na;
    default regwidth = 32; // reg property
    default accesswidth = 32; // reg property

    signal {activelow; async; cpuif_reset; field_reset;} reset_b;
    signal {activelow; async;} error_reset_b; // Driven by Caliptra pwrgood from SoC

    /* -----------------------
    * Register definitive definitions
    * ----------------------- */

    /* ---- SHA3 KMAC FIXME ---- */
    reg {
        name = "SHA3/SHAKE component name register type definition";
        desc = "Two 32-bit read-only registers representing the name
                of SHA3/SHAKE component.";

        default sw = r;
        default hw = w;
        field {desc = "Name field";} NAME[32];

    } FIXME1 @0x00000000;



    /* ---- SHA3 Component Version ---- */
    reg {
        name = "SHA3/SHAKE component version register type definition";
        desc = "Two 32-bit read-only registers representing the version
                of SHA3/SHAKE component.";

        default sw = r;
        default hw = w;
        field {desc = "Version field";} VERSION[32];

    } FIXME2 @0x00000008;


    reg {
        name = "SHA3/SHAKE component Alert Test Register";
        field {
            sw = w;
            reset = 0x0;
            desc = "Write 1 to trigger one alert event of this kind.";
        } RECOV_OPERATION_ERR[0:0];
        field {
            sw = w;
            reset = 0x0;
            desc = "Write 1 to trigger one alert event of this kind.";
        } FATAL_FAULT_ERR[1:1];
    } ALERT_TEST @ 0x1C;

    reg {
        name = "SHA3/SHAKE component Write enable for CFG_SHADOWED register";
        field {
            sw = r;
            hw = rw;
            desc = "Configuration enable.";
            reset = 0x1;
        } en[0:0];
    } CFG_REGWEN @0x20;

    reg {
        name = "SHA3/SHAKE component Configuration register";
        //Since this is a shadowed register which is not supported by systemrdl, we use external implementation
        //TBD, do we need shadowed regï¼Ÿ There is no safety and security requirement.
        desc = "This register is shadowed and protected by CFG_REGWEN.en
        1. Two subsequent write operation are required to change its content,
        If the two write operations try to set a different value, a recoverable alert is triggered (See Status Register).
        2. A read operation clears the internal phase tracking.
        3. If storage error(~staged_reg!=committed_reg) happen, it will trigger fatal fault alert";
        default hw = r; 


        field {
            sw = rw;
            reset = 0x0;
            desc = "Hashing Strength, Protected by CFG_REGWEN.en
            bit field to select the security strength of SHA3 hashing engine. 
            If mode field is set to SHAKE, only 128 and 256 strength can be selected. 
            Other value will result error when hashing starts.";
            enum kstrength_type{
                // | Value | Name | Description |
                // |-------|------|-------------|
                // | 0x0   | L128 | 128-bit strength |
                // | 0x1   | L224 | 224-bit strength |
                // | 0x2   | L256 | 256-bit strength |
                // | 0x3   | L384 | 384-bit strength |
                // | 0x4   | L512 | 512-bit strength |
                L128 = 0x0;
                L224 = 0x1;
                L256 = 0x2;
                L384 = 0x3;
                L512 = 0x4;
            };
        } kstrength[3:1];

        field {
            sw = rw;
            reset = 0x0;
            desc = "Keccak hashing mode, Protected by CFG_REGWEN.en
            This module supports SHA3 main hashing algorithm and the part of its derived functions, 
            SHAKE with limitations. This field is to select the mode.";
            enum sha3_mode_type{
                // | Value | Name | Description |
                // |-------|------|-------------|
                // | 0x0   | SHA3 | Standard SHA3 hashing |
                // | 0x1   | SHAKE | SHAKE hashing mode |
                SHA3 = 0x0;
                SHAKE = 0x1;
            };
        } mode[5:4];

        field {
            sw = rw;
            reset = 0x0;
            desc = "Protected by CFG_REGWEN.en
            If 1 then each individual multi-byte value, regardless of its alignment, 
            written to MSG_FIFO will be added to the message in big-endian byte order. 
            If 0, each value will be added to the message in little-endian byte order. 
            A message written to MSG_FIFO one byte at a time will not be affected by this setting. 
            From a hardware perspective byte swaps are performed on a TL-UL word granularity.";
            enum msg_endian_type{
                LITTLE_ENDIAN = 0x0;
                BIG_ENDIAN = 0x1;
            };
        } msg_endianness[8:8];

        field {
            sw = rw;
            reset = 0x0;
            desc = "Protected by CFG_REGWEN.en
            If 1 then each individual multi-byte value, regardless of its alignment, 
            written to MSG_FIFO will be added to the message in big-endian byte order. 
            If 0, each value will be added to the message in little-endian byte order. 
            A message written to MSG_FIFO one byte at a time will not be affected by this setting. 
            From a hardware perspective byte swaps are performed on a TL-UL word granularity.";
            enum state_endian_type {
                LITTLE_ENDIAN = 0x0;
                BIG_ENDIAN = 0x1;
            };
        } state_endianness[9:9];

    } external CFG_SHADOWED @ 0x24;

    reg {
        name = "SHA3/SHAKE component command register";
        default hw = r; 
        field {
            sw = rw;
            reset = 0x0;
            onwrite = woclr;
            //onread = r0;
            //hw force return 0 for sw read
            desc = "Issues a command to the SHA3 IP. The command is sparse encoded. 
            To prevent sw from writing multiple commands at once, the field is defined as enum.
            Always return 0 for SW reads.
            START: Writing 6'b011101 or dec 29 into this field when SHA3/SHAKE is in idle, SHA3/SHAKE begins its operation and start absorbing.
            PROCESS: Writing 6'b101110 or dec 46 into this field when SHA3/SHAKE began its operation and received the entire message, it computes the digest or signing.
            RUN: The run field is used in the sponge squeezing stage. 
            It triggers the keccak round logic to run full 24 rounds. 
            This is optional and used when software needs more digest bits than the keccak rate. 
            It only affects when the SHA3/SHAKE operation is completed.
            DONE: Writing 6'b010110 or dec 22 into this field when SHA3 squeezing is completed, 
            SHA3/SHAKE hashing engine clears internal variables and goes back to Idle state for next command.";
            enum cmd_type{
                //| Value (dec) | Value (hex) | Value (bin) | Name | Description |
                //|------------|-------------|-------------|------|-------------|
                //| 29 | 0x1D | 6'b011101 | START | Start SHA3/SHAKE operation and begin absorbing |
                //| 46 | 0x2E | 6'b101110 | PROCESS | Process the entire message and compute digest |
                //| 49 | 0x31 | 6'b110001 | RUN | Run Keccak round logic for squeezing stage |
                //| 22 | 0x16 | 6'b010110 | DONE | Clear internal state and return to idle |
                START = 0x1D;
                PROCESS = 0x2E;
                RUN = 0x31;
                DONE = 0x16;
            } ;
        } cmd[5:0];

        field {
            sw = rw;
            reset = 0x0;
            onwrite = woclr;
            //onread = r0;
            //hw force return 0 for sw read
            desc = "When error occurs and one of the state machine stays at Error handling state, 
            SW may process the error based on ERR_CODE, then let FSM back to the reset state.
            Always return 0 for SW reads.";
        } err_processed[10:10];
    } CMD @ 0x28;

    reg {
        default hw = w; 
        name = "SHA3/SHAKE component status register";
        field {
            sw = r;
            reset = 0x1;
            desc = "If 1, SHA3 hashing engine is in idle state.";
        } sha3_idle[0:0];

        field {
            sw = r;
            reset = 0x0;
            desc = "If 1, SHA3 is receiving message stream and processing it";
        } sha3_absorb[1:1];

        field {
            sw = r;
            reset = 0x0;
            desc = "If 1, SHA3 completes sponge absorbing stage. In this stage, SW can manually run the hashing engine.";
        } sha3_squeeze[2:2];

        field {
            sw = r;
            reset = 0x0;
            desc = "Count of occupied entries in the message FIFO.";
        } fifo_depth[12:8];

        field {
            sw = r;
            reset = 0x1;
            desc = "Message FIFO Empty indicator.
            The FIFO's Pass parameter is set to 1'b 1. So, by default, if the SHA engine is ready, the write data to FIFO just passes through.
            In this case, fifo_depth remains 0. fifo_empty, however, lowers the value to 0 for a cycle, then goes back to the empty state, 1.
            See the Message FIFO section in the spec for the reason.";
        } fifo_empty[14:14];

        field {
            sw = r;
            reset = 0x0;
            desc = "Message FIFO Full indicator.";
        } fifo_full[15:15];

        field {
            sw = r;
            reset = 0x0;
            desc = "No fatal fault has occurred inside the SHA3 unit (0). 
            A fatal fault has occured and the SHA3 unit needs to be reset (1), 
            Examples for such faults include i) TL-UL bus integrity fault 
            ii) storage errors in the shadow registers 
            iii) errors in the message, round, or key counter 
            iv) any internal FSM entering an invalid state.";
        } ALERT_FATAL_FAULT[16:16];

        field {
            sw = r;
            reset = 0x0;
            desc = "An update error has not occurred (0) or has occured (1) in the shadowed Control Register. 
            SHA3 operation needs to be restarted by re-writing the Control Register.";
        } ALERT_RECOV_CTRL_UPDATE_ERR[17:17];

    } STATUS @ 0x2C;

    reg {
        default hw = w; 
        name = "SHA3/SHAKE component error code register";
        desc = "SHA3 Error Code";
        field {
            desc = "If the error_internal_intr_r.sha3_error_sts interrupt occurs, this register has information on the error cause.
            Bits 31:24 contain the error code for the encoding, and bits 23:0 contain additional debug information.
            This register does *not* get cleared when the error_internal_intr_r.sha3_error_sts interrupt state gets cleared.";
            sw = r;
            reset = 0x0;
            enum err_code_type{
                // | Value | Name | Description |
                // |-------|------|-------------|
                // | 0x00  | ErrNone | No error |
                // | 0x02  | ERR_SW_PUSHED_MSGFIFO | Software pushed message to FIFO incorrectly |
                // | 0x06  | ErrUnexpectedModeStrength | Unexpected mode/strength combination |
                // | 0x07  | ERR_INCORRECT_FUNCTION_NAME | Incorrect function name |
                // | 0x08  | ERR_SW_CMD_SEQUENCE | Incorrect command sequence |
                // | 0xC1  | ERR_FATAL_ERROR | Fatal error occurred |
                ErrNone = 8'h00;

                // ErrSwPushMsgFifo: Sw writes data into Msg FIFO abruptly.
                // This error occurs in below scenario:
                //   - Sw does not send "Start" command to SHA3 then writes data into
                //     Msg FIFO
                //   - Sw writes data into Msg FIFO when KeyMgr is in operation
                ERR_SW_PUSHED_MSGFIFO = 8'h02;

                // Err_Unexpected_ModeStrength
                ErrUnexpectedModeStrength = 8'h06;

                // ErrIncorrectFunctionName "SHA3"
                ERR_INCORRECT_FUNCTION_NAME = 8'h07;

                // ErrSwCmdSequence
                ERR_SW_CMD_SEQUENCE = 8'h08;

                // Error due to lc_escalation_en_i or fatal fault
                ERR_FATAL_ERROR = 8'hC1;

            };
        } ERR_CODE[31:0];
    } ERR_CODE @ 0xD0;

    mem {
        name = "SHA3/SHAKE component Keccak State memory";
        sw = r;
        mementries = 0x40;
        memwidth = 0x20;
        desc = "Keccak State (1600 bit) memory.
        The software can get the processed digest by reading this memory
        region. Unlike MSG_FIFO, STATE memory space sees the addr[9:0].
        If Masking feature is enabled, the software reads two shares from
        this memory space.
        0x200 - 0x2C7: State share
        for Keccak State access:
        1. Output length <= rate length, sha3_done will be raised or software can poll STATUS.squeeze become 1.
        2. Output length > rate length, after software read 1st keccak state, software should issue run cmd to trigger keccak round logic to run full 24 rounds.
        And then software should check STATUS.squeeze register field for the readiness of STATE value(SHA3 FSM become MANUAL_RUN before keccak state complete).";
    } external STATE @ 0x400;

    mem {
        name = "SHA3/SHAKE component Message FIFO";
        sw = w;
        mementries = 0x40;
        memwidth = 0x20;
        desc = "Message FIFO. window size is 2048 bytes.
        Any write operation to this window will be appended to MSG_FIFO. SW can
        simply write bytes/words to any address within this address range.
        Ordering and packing of the incoming bytes/words are handled
        internally. Therefore, the least significant 10 bits of the address
        are ignored.";
    } external MSG_FIFO @ 0x800;

};
