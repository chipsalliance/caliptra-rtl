// SPDX-License-Identifier: Apache-2.0
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//


addrmap hmac_reg {
    desc="address maps for HMAC384 register space";


    addressing = regalign; // This is the default if not specified
    lsb0 = true; // lsb0 property is implicit/default. See docs for
                 // SystemRDL 2.0 sections 9.1 and 13.4

    default hw = na;
    signal {activelow; async; cpuif_reset; field_reset;} reset_b;

    /* -----------------------
    * Register definitive definitions
    * ----------------------- */

    /* ---- HMAC384 Component Name ---- */
    reg {
        name = "HMAC384 component name register type definition";
        desc = "Two 32-bit read-only registers repereseting of the name
                of HMAC384 component. These registers are located at
                HMAC384_base_address + 0x0000_0000 and 0x0000_0004 addresses.";

        default sw = r;
        default hw = w;
        field {desc = "Name field";} NAME[32];

    } HMAC384_NAME[2] @0x00000000;



    /* ---- HMAC384 Component Version ---- */
    reg {
        name = "HMAC384 component version register type definition";
        desc = "Two 32-bit read-only registers repereseting of the version
                of HMAC384 component. These registers are located at
                HMAC384_base_address + 0x0000_0008 and 0x0000_000C addresses.";

        default sw = r;
        default hw = w;
        field {desc = "Version field";} VERSION[32];
        
    } HMAC384_VERSION[2] @0x00000008;



    /* ---- HMAC384 Component Control ---- */
    reg {
        name = "HMAC384 component control register type definition";
        desc = "One 2-bit register including the following flags: 
                bit #0: INIT : Trigs the HMAC384 core to start the 
                                processing for the key and the first padded 
                                message block.
                bit #1: NEXT: ​Trigs the HMAC384 core to start the 
                                processing for the remining padded message block. 
                This register is located at HMAC384_base_address + 0x0000_0010
                After each software write, hardware will erase the register.";

        default sw = w;
        default hw = rw;
        default resetsignal = reset_b;
        field {desc = "Control init command bit";} INIT = 1'b0;
        field {desc = "Control next command bit";} NEXT = 1'b0;
    
    } HMAC384_CTRL @0x00000010;



    /* ---- HMAC384 Component Status ---- */
    reg {
        name = "HMAC384 component status register type definition";
        desc = "One 2-bit register including the following flags: 
                bit #0: READY : ​Indicates if the core is ready to take
                                a control command and process the block.  
                bit #1: Valid: ​Indicates if the process is done and the
                                results stored in TAG registers are valid. 
                This register is located at HMAC384_base_address + 0x0000_0018.";

        default sw = r;
        default hw = w;
        default resetsignal = reset_b;
        field {desc = "Status ready bit";} READY = 1'b0;
        field {desc = "Status valid bit";} VALID = 1'b0;
    
    } HMAC384_STATUS @0x00000018;


    
    /* ---- HMAC384 Component Input Key ---- */
    reg {
        name = "HMAC384 component key register type definition";
        desc = "12 32-bit registers storing the 384-bit key.
                These registers are located at HMAC384_base_address + 
                0x0000_0040 to 0x0000_006C in big-endian representation.";

        default sw = w;
        default hw = r;
        default resetsignal = reset_b;
        field {desc = "Input HMAC384 key field";} KEY[32] = 32'b0;
    
    } HMAC384_KEY[12] @0x00000040;



    /* ---- HMAC384 Component Input Message Block ---- */
    reg {
        name = "HMAC384 component block register type definition";
        desc = "32 32-bit registers storing the 1024-bit padded input.
                These registers are located at HMAC384_base_address + 
                0x0000_0080 to 0x0000_00FC in big-endian representation.";

        default sw = w;
        default hw = r;
        default resetsignal = reset_b;
        field {desc = "Input message block field";} BLOCK[32] = 32'b0;
    
    } HMAC384_BLOCK[32] @0x00000080;

    

    /* ---- HMAC384 Component Output Tag ---- */
    reg {
        name = "HMAC384 component tag register type definition";
        desc = "12 32-bit registers storing the 384-bit digest output.
                These registers are located at HMAC384_base_address + 
                0x0000_0100 to 0x0000_012C in big-endian representation.";

        default sw = r;
        default hw = w;
        default resetsignal = reset_b;
        field {desc = "Output tag field";} TAG[32] = 32'b0;
    
    } HMAC384_TAG[12] @0x00000100;

    /* ---- HMAC384 Key Vault Control Reg ---- */
    reg {
        name = "HMAC384 Key Vault Control Register";
        desc = "Controls the Key Vault access for HMAC384";

        default sw = rw;
        default hw = r;
        default resetsignal = reset_b;

        field {desc = "Indicates that the key value is to come from the key vault";} key_sel_en = 0;
        field {desc = "Key Vault entry to retrieve the key for the engine";} key_sel[3] = 0;
        field {desc = "Key selected is a PCR slot";} key_sel_pcr = 0;
        field {desc = "Reserved field";} rsvd_key_sel[3] = 0;
        field {desc = "Indicates that the source value is to come from the key vault";} src_sel_en = 0;
        field {desc = "Key Vault entry to retrieve the source for the engine";} src_sel[3] = 0;
        field {desc = "Source selected is a PCR slot";} src_sel_pcr = 0;
        field {desc = "Size of the source data for padding function.
                       Size is encoded as N-1 128 bits of data.
                       Padding is generated for size values 0-5.";} src_data_size[3] = 0;
        field {desc = "Indicates that the result is to be stored in the key vault";} dest_sel_en = 0;
        field {desc = "Key Vault entry to store the result";} dest_sel[3] = 0;
        field {desc = "Destination selected is a PCR slot";} dest_sel_pcr = 0;
        field {desc = "Reserved field";} rsvd_dest_sel[3] = 0;
        field {desc = "Destination valid bits. Determines where the result
                       of the crypto function can be used after being stored
                       in the key vault.";} dest_valid[3] = 0;
        field {desc = "Reserved field";} rsvd1[2] = 0;
        field {desc = "Key has been copied form key vault to engine";} key_done = 0;
        field {desc = "Source has been copied from key vault to engine";} src_done = 0;
        field {desc = "Result has been copied to key vault";} dest_done = 0;

    
    } HMAC384_KV_CTRL @0x00000200;
};